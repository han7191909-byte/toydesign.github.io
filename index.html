<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Warp Stage1+2+3 Deep Space Edition</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <style>
    @font-face {
      font-family: "Kan412TyposStd";
      src: url("fonts/Kan412TyposStd-Regular.otf") format("opentype");
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: "Kan410TyposStd";
      src: url("fonts/Kan410TyposStd-Regular.otf") format("opentype");
      font-weight: normal;
      font-style: normal;
    }
    body {
  font-family: "Zen Maru Gothic", sans-serif;
}

    html, body {
      margin:0;
      overflow:hidden;
      background:#000;
    }
    #threeContainer{
      position:fixed;
      inset:0;
      z-index:1;
    }
    #artCanvas{
      position:fixed;
      inset:0;
      z-index:5;
      background:transparent;
      pointer-events:none;
    }
    #uiCanvas{
      position:fixed;
      inset:0;
      z-index:6;
      background:transparent;
      pointer-events:none;
    }
    #goStage3Btn{
      position:fixed;
      top:1.6vmin;
      right:1.6vmin;
      z-index:20;
      padding:1.2vmin 2vmin;
      font-size:2vmin;
      background:rgba(20,25,40,0.85);
      border:0.1vmin solid rgba(255,255,255,0.4);
      color:white;
      border-radius:0.8vmin;
      cursor:pointer;
      display:none;
    }
    #galleryBtn{
      position:fixed;
      top:1.6vmin;
      left:1.6vmin;
      z-index:20;
      padding:1.2vmin 2vmin;
      font-size:2vmin;
      background:rgba(20,25,40,0.85);
      border:0.1vmin solid rgba(255,255,255,0.4);
      color:white;
      border-radius:0.8vmin;
      cursor:pointer;
      display:none;
    }
    #videoElement{
      display:block;
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      z-index:2;
      opacity:0;
      pointer-events:none;
      transform:scaleX(-1);
      transition:opacity 0.3s ease;
    }
    #videoElement.stage1Visible{
      opacity:0.2;
    }
    /* 画廊覆盖层 */
    #galleryOverlay{
      position:fixed;
      inset:0;
      z-index:60;
      background:rgba(0,0,0,0.85);
      display:none;
      color:white;
      padding:2.8vmin;
      box-sizing:border-box;
    }
    #galleryOverlay .closeBtn{
      position:absolute;
      top:1.2vmin;
      right:1.2vmin;
      background:transparent;
      border:0.1vmin solid rgba(255,255,255,0.25);
      color:white;
      padding:0.6vmin 1vmin;
      border-radius:0.6vmin;
      cursor:pointer;
    }
    #galleryInner{
      position:relative;
      margin-top:0.8vmin;
      height:calc(100% - 6.4vmin);
      overflow-x:auto;
      overflow-y:hidden;
      white-space:nowrap;
      display:flex;
      flex-wrap:wrap;
      align-content:flex-start;
      gap:1.2vmin;
      padding-bottom:1.2vmin;
    }
    .galleryTile{
      display:inline-block;
      width:26vmin;
      height:15vmin;
      background:rgba(10,12,18,0.6);
      border:0.1vmin solid rgba(255,255,255,0.08);
      border-radius:0.8vmin;
      padding:0.6vmin;
      box-sizing:border-box;
      flex: 0 0 auto;
      position:relative;
    }
    .galleryTile img{
      width:100%;
      height:100%;
      object-fit:cover;
      border-radius:0.6vmin;
      display:block;
    }
    .galleryMeta{
      position:absolute;
      left:0.8vmin;
      bottom:0.8vmin;
      right:4.8vmin;
      font-size:1.2vmin;
      color:#fff;
      text-shadow:0 0.1vmin 0.4vmin rgba(0,0,0,0.6);
    }
    .galleryDel{
      position:absolute;
      right:0.8vmin;
      bottom:0.8vmin;
      padding:0.6vmin;
      background:rgba(255,20,20,0.95);
      border-radius:0.6vmin;
      cursor:pointer;
      font-size:1.2vmin;
      border:none;
      color:white;
    }

    /* 标题覆盖层 */
    #titleOverlay{
      position:fixed;
      inset:0;
      z-index:40;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
      color:white;
      font-family: "Kan412TyposStd", "漢字タイポス４１２ Std", "Helvetica Neue", Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      background: transparent;
    }
    #titleCard{
      text-align:center;
      padding:0;
      background: none;
      border: none;
      transform: translateY(-3.5vmin);
    }
    @keyframes floatY {
      0% { transform: translateY(0vmin); }
      50% { transform: translateY(-1vmin); }
      100% { transform: translateY(0vmin); }
    }
    @keyframes glow {
      0% { text-shadow: 0 0 0.6vmin rgba(255,255,255,0.55), 0 0 2vmin rgba(120,180,255,0.06); }
      50% { text-shadow: 0 0 1.8vmin rgba(255,255,255,0.95), 0 0 4vmin rgba(120,180,255,0.25); }
      100% { text-shadow: 0 0 0.6vmin rgba(255,255,255,0.55), 0 0 2vmin rgba(120,180,255,0.06); }
    }
    #titleCard h1{
      margin:0 0 1.5vmin 0;
      font-size:5vmin;
      font-family: "Kan412TyposStd", "漢字タイポス４１２ Std", "Helvetica Neue", Arial, sans-serif;
      letter-spacing:0.5vmin;
      color:#eaf6ff;
      text-shadow:
        0 0 0.6vmin rgba(210,240,255,0.9),
        0 0.8vmin 2.4vmin rgba(10,16,30,0.55);
      animation: floatY 3.8s ease-in-out infinite, glow 2.6s ease-in-out infinite;
      will-change: transform, text-shadow;
    }
    #stageSelectButtons{
      margin-top:3.2vmin;
      display:none;
      flex-direction:column;
      gap:1.2vmin;
      align-items:center;
    }
    #stageSelectButtons.visible{
      display:flex;
    }
    .stageSelectBtn{
      padding:1.5vmin 3vmin;
      font-size:2vmin;
      background:rgba(20,25,40,0.75);
      border:0.1vmin solid rgba(255,255,255,0.3);
      color:white;
      border-radius:1vmin;
      cursor:pointer;
      transition:all 0.3s ease;
      min-width:25vmin;
      letter-spacing:0.15vmin;
    }
    .stageSelectBtn:hover{
      background:rgba(40,50,70,0.85);
      border-color:rgba(255,255,255,0.5);
      transform:translateY(-0.2vmin);
      box-shadow:0 0.4vmin 1.2vmin rgba(120,180,255,0.3);
    }

    /* --- Style 01: Cinematic Blur (电影字幕风) --- */
    #tipOverlay {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* 允许点击穿透 */
      background: transparent; /* 移除背景色，只展示文字 */
      perspective: 100vmin;
    }
    #tipText {
      font-family: "Kan410TyposStd", "漢字タイポス４１０ Std", "Helvetica Neue", Arial, sans-serif;
      font-size: 2vmin;
      font-weight: 500;
      line-height: 1.8;
      color: #fff;
      text-align: center;
      letter-spacing: 0.2em; /* 宽字间距增加高级感 */
      max-width: 80vw;
      margin: 0 auto;
      margin-top: 7vmin; /* 向下移动 */
      /* 核心：光晕效果 */
      text-shadow: 0 0 1vmin rgba(255,255,255,0.6), 0 0 2vmin rgba(180,220,255,0.4), 0 0 4vmin rgba(180,220,255,0.2);
      /* 动画初始状态：模糊、微放大、透明 */
      opacity: 0;
      transform: scale(1.1);
      filter: blur(1vmin);
      /* 优雅的长过渡 */
      transition: opacity 1.5s cubic-bezier(0.2, 0.8, 0.2, 1), transform 1.5s cubic-bezier(0.2, 0.8, 0.2, 1), filter 1.5s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    /* 激活状态：清晰、聚焦 */
    #tipOverlay.visible #tipText {
      opacity: 1;
      transform: scale(1);
      filter: blur(0vmin);
    }

    /* Container for the clockwork animation */
    .s1-wrap {
      position: relative;
      width: 60vmin;
      height: 60vmin;
      display: flex;
      justify-content: center;
      align-items: center;
      transform: scale(0.65); /* Scale down to 65% as requested */
    }

    /* --- OUTER RING --- */
    .s1-ring-outer {
      position: absolute;
      width: 38.4vmin; height: 38.4vmin;
      border-radius: 50%;
      border: 0.1vmin solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 3vmin rgba(255, 255, 255, 0.1);
      animation: rotate-cw 80s linear infinite;
      opacity: 0; transform: scale(0.9);
      transition: opacity 1.5s, transform 1.5s cubic-bezier(0.2, 1, 0.3, 1);
    }
    .s1-ring-outer::after {
      content: ''; position: absolute; inset: 0.4vmin; border-radius: 50%;
      border: 0.1vmin solid rgba(255, 255, 255, 0.15);
    }

    /* --- MID RING (SVG) --- */
    .s1-ring-svg {
      position: absolute;
      width: 28.8vmin; height: 28.8vmin;
      animation: rotate-cw 40s linear infinite;
      opacity: 0; transform: scale(0.8);
      transition: opacity 1.2s, transform 1.2s cubic-bezier(0.2, 1, 0.3, 1);
    }

    .svg-circle-path {
      fill: none;
      stroke: #ffffff;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-dasharray: 570;
      stroke-dashoffset: 570; /* Initial hidden */
    }

    /* Active State: SVG Fade In & Draw */
    .s1-wrap.active .s1-ring-svg { opacity: 1; transform: scale(1); }
    .s1-wrap.active .svg-circle-path { animation: draw-circle 2s cubic-bezier(0.4, 0, 0.2, 1) forwards 0.3s; }
    @keyframes draw-circle { to { stroke-dashoffset: 0; } }

    /* --- PARTICLES --- */
    .orbit-layer {
      position: absolute; inset: 0;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0; transition: opacity 1s ease 0.5s;
    }
    .s1-wrap.active .orbit-layer { opacity: 1; }

    .layer-slow { animation: rotate-cw 100s linear infinite; }
    .layer-med  { animation: rotate-cw 60s linear infinite; }
    .layer-fast { animation: rotate-cw 30s linear infinite; }

    .star-p {
      position: absolute;
      background: #fff5d0; /* Gold glow */
      border-radius: 50%;
      top: 50%; left: 50%;
      opacity: 0; transform: translate(0, 0) scale(0);
    }

    @keyframes star-fade-in {
      0% { opacity: 0; transform: var(--target-transform) scale(0); }
      50% { opacity: var(--target-opacity); transform: var(--target-transform) scale(1.2); }
      100% { opacity: var(--target-opacity); transform: var(--target-transform) scale(1); }
    }

    /* --- TEXT --- */
    .s1-text-box {
      z-index: 999;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #eecfa1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2vmin;
      width: 100%;
      pointer-events: none;
    }

    .s1-title {
      font-family: "Kan412TyposStd", "漢字タイポス４１２ Std", "Helvetica Neue", Arial, sans-serif;
      font-size: 3.6vmin;
      font-weight: 500;
      letter-spacing: 0.2em;
      color: #ffffff;
      /* 淡黄色多层光晕，与其他标语统一风格 */
      text-shadow: 0 0 1vmin rgba(255,245,200,0.65), 0 0 2.2vmin rgba(238,207,161,0.45), 0 0 4.6vmin rgba(238,207,161,0.22);
      margin: 0; white-space: nowrap;
      opacity: 0; transform: scale(1.1); filter: blur(1vmin);
      transition: all 1.8s cubic-bezier(0.2, 1, 0.3, 1) 0.5s;
    }

    .s1-line {
      width: 0; height: 0.1vmin;
      background: linear-gradient(90deg, transparent, #ffffff, transparent);
      opacity: 0.8;
      transition: width 1.2s ease 1s;
    }

    .s1-desc {
      font-family: "Kan412TyposStd", "漢字タイポス４１２ Std", "Helvetica Neue", Arial, sans-serif;
      font-size: 2.4vmin;
      font-weight: 400;
      line-height: 1.8;
      color: rgba(255,255,255,0.9);
      letter-spacing: 0.1em;
      white-space: nowrap;
      /* 与标题一致的淡黄色光晕 */
      text-shadow: 0 0 0.8vmin rgba(255,245,200,0.55), 0 0 1.8vmin rgba(238,207,161,0.38), 0 0 3.6vmin rgba(238,207,161,0.18);
      opacity: 0; transform: translateY(1vmin);
      transition: all 1.2s ease 1.2s;
    }

    /* Active State: Text */
    .s1-wrap.active .s1-ring-outer { opacity: 1; transform: scale(1); }
    .s1-wrap.active .s1-title { opacity: 1; transform: scale(1); filter: blur(0); }
    .s1-wrap.active .s1-line { width: 14vmin; }
    .s1-wrap.active .s1-desc { opacity: 1; transform: translateY(0); }

    @keyframes rotate-cw { from{transform:rotate(0deg);} to{transform:rotate(360deg);} }

    #fadeOverlay{
      position:fixed;
      inset:0;
      z-index:45;
      background:transparent !important;
      opacity:0;
      transition:opacity 0.8s ease;
      pointer-events:none;
      display:none;
    }
    #fadeOverlay.visible{
      opacity:1;
    }

    /* =========================================
       Stage 2 工具栏 - 竖向悬浮球风格 + 手势悬停支持
       ========================================= */
    #toolOverlay {
      position: fixed;
      top: 50%;
      right: 10vmin;
      transform: translateY(-50%);
      z-index: 30;
      display: none; /* JS控制显示 */
      flex-direction: column; /* 竖向排列 */
      gap: 1.6vmin; /* 球体之间的间距 */
      pointer-events: none; /* 容器透传点击 */
    }
    /* 按钮基础样式：飘渺悬浮球 */
    .toolBuoy {
      width: 6vmin;
      height: 6vmin;
      border-radius: 50%;
      /* 核心：半透明渐变，模拟玻璃球体 */
      background: linear-gradient(145deg, rgba(58, 57, 87, 0.15), rgba(44, 45, 107, 0.02));
      /* 柔和的边框光 */
      border: 0.1vmin solid rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.6);
      
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: auto; /* 按钮自身可点击/交互 */
      
      position: relative;
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 弹性动画 */
      box-shadow: 0 0.3vmin 1vmin rgba(0,0,0,0.2);
    }
    /* 内部高光效果 (光泽感) */
    .toolBuoy::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: radial-gradient(circle at 50% 0%, rgba(25, 32, 106, 0.5), transparent 60%);
      opacity: 0.4;
      transition: opacity 0.3s ease;
    }
    /* SVG 图标样式 */
    .toolBuoy svg {
      width: 1.7vmin;
      height: 1.7vmin;
      fill: currentColor;
      opacity: 0.8;
      transition: transform 0.3s ease;
    }
    /* 悬停状态：同时支持鼠标 :hover 和 手势 .hand-hover */
    .toolBuoy:hover,
    .toolBuoy.hand-hover {
      transform: scale(1.15); /* 放大 */
      background: linear-gradient(145deg, rgba(255,255,255,0.25), rgba(255,255,255,0.05));
      color: #fff;
      border-color: rgba(255,255,255,0.4);
      box-shadow: 0 0 1.3vmin rgba(255,255,255,0.2);
    }
    /* 激活状态 (选中) */
    .toolBuoy.active {
      background: #ffffff;
      color: #05070a; /* 反色：黑字 */
      border-color: #fff;
      transform: scale(1.1);
      box-shadow: 0 0 2vmin rgba(255,255,255,0.5); /* 强烈的白色光晕 */
    }
    /* 激活时隐藏内部高光 */
    .toolBuoy.active::before {
      opacity: 0;
    }
    /* 激活时图标稍微放大 */
    .toolBuoy.active svg {
      transform: scale(1.1);
      opacity: 1;
    }
    /* 隐藏标签文字 */
    .toolLabel {
      display: none;
    }

    #stage1Hint, #stage2Hint, #stage1_5ProgressHint, #stage2TopHint{
      position:fixed;
      top:8vmin;
      left:50%;
      transform:translateX(-50%);
      z-index:28;
      color:#ffffff;
      font-size:1.7vmin;
      font-family: "Kan410TyposStd", "漢字タイポス４１０ Std", "Helvetica Neue", Arial, sans-serif;
      text-align:center;
      display:none;
      pointer-events:none;
      line-height:1.8;
      opacity:0;
      transition:opacity 0.6s ease-in;
      max-width:80vw;
      text-shadow:
        0 0 1vmin rgba(255,255,255,0.8),
        0 0 2vmin rgba(255,255,255,0.5),
        0 0 3vmin rgba(255,255,255,0.3);
    }
    #stage1Hint.visible, #stage2Hint.visible, #stage1_5ProgressHint.visible, #stage2TopHint.visible{
      opacity:1;
    }
    /* stage2TopHint 单独设置字体大小，不换行，位置往上调 */
    #stage2TopHint {
      font-size: 1.7vmin;
      white-space: nowrap;
      top: 6vmin; /* 从8vmin调整为6vmin，往上移动 */
    }
    /* --- 绘画控制小标语样式 --- */
    #drawingControlHint {
      position: fixed;
      bottom: 3vmin;
      left: 50%;
      transform: translateX(-50%);
      z-index: 28;
      color: #ffffff;
      font-size: 1.5vmin;
      font-family: "Kan410TyposStd", "漢字タイポス４１０ Std", "Helvetica Neue", Arial, sans-serif;
      text-align: center;
      display: none;
      pointer-events: none;
      line-height: 1.8;
      opacity: 0;
      transition: opacity 0.6s ease-in;
      white-space: nowrap;
      max-width: 80vw;
      text-shadow:
        0 0 1vmin rgba(255,255,255,0.8),
        0 0 2vmin rgba(255,255,255,0.5),
        0 0 3vmin rgba(255,255,255,0.3);
    }
    #drawingControlHint.visible {
      opacity: 1;
    }
    /* --- Pen 动画样式 --- */
    #penAnimation {
      position: fixed;
      top: 44%;
      left: 47%;
      transform: translate(-50%, -50%) scale(0.16);
      z-index: 27;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    #penAnimation.visible {
      opacity: 1;
    }
    /* Stage 1 手部图片样式 */
    #hand1Image, #hand2Image {
      position: fixed;
      z-index: 52; /* 提高 z-index，确保在 tipOverlay (z-index: 50) 之上 */
      pointer-events: none;
      /* 动画初始状态：模糊、微放大、透明（和 tipText 一样） */
      opacity: 0;
      filter: blur(10px);
      /* 优雅的长过渡（和 tipText 一样） */
      transition: opacity 1.5s cubic-bezier(0.2, 0.8, 0.2, 1), transform 1.5s cubic-bezier(0.2, 0.8, 0.2, 1), filter 1.5s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    #hand1Image.visible, #hand2Image.visible {
      opacity: 1;
      filter: blur(0px);
    }
    /* 2hand图片样式：移到顶部中间 */
    #twoHandImage {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      height: 60px;
      pointer-events: none;
      z-index: 20;
      display: none; /* 初始隐藏 */
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    #twoHandImage.visible {
      opacity: 1;
    }
    /* hand1 在左侧 30%，hand2 在右侧 70% */
    #hand1Image {
      /* 放在屏幕宽度的 30% 处 */
      left: 29%;
      top: 53%;
      /* 初始状态：微放大、居中 */
      transform: translate(-50%, -50%) scale(0.11);
    }
    #hand1Image.visible {
      /* 激活状态：正常大小 */
      transform: translate(-50%, -50%) scale(0.1);
    }
    #hand2Image {
      /* 放在屏幕宽度的 70% 处 */
      left: 73%;
      top: 53%;
      /* 初始状态：微放大、居中 */
      transform: translate(-50%, -50%) scale(0.11);
    }
    #hand2Image.visible {
      /* 激活状态：正常大小 */
      transform: translate(-50%, -50%) scale(0.1);
    }
    /* Star图片样式：居中，叠加显示，缩小5倍 */
    #star1Image, #star2Image, #star3Image {
      position: fixed;
      left: 47%;
      top: 55%;
      transform: translate(-50%, -50%) scale(0.40);
      z-index: 92; /* 在warpTextContainer (z-index: 91) 之上 */
      pointer-events: none;
      opacity: 0;
      transition: opacity 1.5s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    #star1Image.visible, #star2Image.visible, #star3Image.visible {
      opacity: 1;
    }
    /* --- 新增：Stage 1.5 星座进度条样式 --- */
    #stage1_5ProgressBar{
      position:fixed;
      z-index:29;
      display:none;
      pointer-events:none;
      bottom:10vmin;
      left:50%;
      transform:translateX(-50%);
      /* 容器尺寸 */
      width:30vmin;
      height:12vmin;
    }
    #stage1_5ProgressBar.visible{
      display:block;
    }
    /* 捏合识别圈 (Target Zone) */
    .p09-target-zone{
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%, -50%);
      width:7vmin; height:7vmin;
      border-radius:50%;
      border:0.2vmin solid rgba(255, 255, 255, 0.4); /* 更亮、更粗的边框 */
      background:radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); /* 更明显的填充 */
      box-shadow:0 0 1vmin rgba(255, 255, 255, 0.2); /* 基础发光 */
      z-index:0;
      /* 待机动画：缓慢呼吸，提示用户捏这里 */
      animation:breathe 3s ease-in-out infinite;
      transition:all 0.2s ease-out;
    }
    /* 捏合激活状态：微缩、微亮、无动画 (不抢进度条风头) */
    .p09-target-zone.active{
      animation:none; /* 停止呼吸 */
      transform:translate(-50%, -50%) scale(0.9); /* 微微缩小，模拟受力 */
      border-color:rgba(238, 207, 161, 0.5); /* 变淡金 */
      background:radial-gradient(circle, rgba(238, 207, 161, 0.1) 0%, transparent 70%);
      box-shadow:0 0 1.5vmin rgba(238, 207, 161, 0.2); /* 微弱光晕 */
    }
    @keyframes breathe{
      0%, 100% { 
        transform:translate(-50%, -50%) scale(1); 
        border-color:rgba(255,255,255,0.4); 
        box-shadow:0 0 1vmin rgba(255,255,255,0.2); 
      }
      50% { 
        transform:translate(-50%, -50%) scale(1.15); /* 呼吸幅度稍微加大 */
        border-color:rgba(255,255,255,0.9); /* 呼吸时变很亮 */
        box-shadow:0 0 3vmin rgba(255,255,255,0.6); /* 强烈的呼吸光晕 */
      }
    }
    /* 进度条结构 */
    .p09-bar-wrapper{
      position:absolute;
      top:50%; left:0;
      width:100%; height:2vmin;
      transform:translateY(-50%);
      z-index:1;
    }
    /* 背景线 (暗) */
    .p09-line-bg{
      position:absolute; top:50%; left:0; width:100%; height:0.1vmin; 
      background:rgba(255,255,255,0.15);
    }
    /* 进度线 (亮) */
    .p09-line-fg{
      position:absolute; top:50%; left:0; width:0%; height:0.2vmin;
      background:#fff;
      box-shadow:0 0 0.8vmin #fff; /* 发光强度高于圆圈 */
      transition:width 0.1s linear;
    }
    /* 节点 (星星) */
    .p09-dot{
      position:absolute; top:50%; margin-top:-0.3vmin; 
      width:0.6vmin; height:0.6vmin; 
      background:#222; border:0.1vmin solid #555; border-radius:50%; 
      transition:all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .d1 { left:0%; }
    .d2 { left:33%; }
    .d3 { left:66%; }
    .d4 { left:100%; margin-left:-0.6vmin; }
    /* 节点激活 */
    .p09-dot.active{ 
      background:#fff; border-color:#fff; 
      box-shadow:0 0 1.2vmin #fff, 0 0 0.5vmin var(--gold);
      transform:scale(1.6); 
    }
    #stage1Hint .countdown-text{
      font-size: 2vmin;
      animation:stage1Glow 1.5s ease-in-out infinite;
    }
    @keyframes stage1Glow {
      0%, 100% {
        text-shadow:
          0 0 1vmin rgba(255,255,255,0.8),
          0 0 2vmin rgba(255,255,255,0.5),
          0 0 3vmin rgba(255,255,255,0.3);
      }
      50% {
        text-shadow:
          0 0 2vmin rgba(255,255,255,1),
          0 0 4vmin rgba(255,255,255,0.8),
          0 0 6vmin rgba(255,255,255,0.5);
      }
    }

    #stage3BoundaryHint{
      position:fixed;
      top:50%;
      right:2.4vmin;
      transform:translateY(-50%);
      z-index:30;
      color:#e2f3ff;
      font-size:1.2vmin;
      padding:0.6vmin 1.2vmin;
      border-radius:99.9vmin;
      background:rgba(10,18,30,0.45);
      border:0.1vmin solid rgba(180,220,255,0.55);
      box-shadow:0 0 1vmin rgba(120,180,255,0.35);
      text-shadow:0 0 0.6vmin rgba(120,180,255,0.7);
      display:none;
      pointer-events:none;
      white-space:nowrap;
      animation:pulse 1.6s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.8; transform: translateY(-50%) scale(1); }
      50% { opacity: 1; transform: translateY(-50%) scale(1.05); }
    }
    
    /* 穿越文字样式 */
    .warpTextLine {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 1.8vmin;
      font-family: "Kan410TyposStd", "漢字タイポス４１０ Std", "Helvetica Neue", Arial, sans-serif;
      line-height: 1.8;
      text-align: center;
      white-space: nowrap;
      opacity: 1;
      text-shadow: 0 0 1vmin rgba(255, 255, 255, 0.8),
                   0 0 2vmin rgba(255, 255, 255, 0.5);
      transition: opacity 1.5s ease-out, transform 1.5s ease-out;
      width: 100%;
    }
    .warpTextLine.fadeUp {
      opacity: 0;
      transition: opacity 5s ease-out, transform 1.5s ease-out;
    }
    
 /* QR 弹窗 - C1 (Ultra Transparent) 样式 */
.transparent {
  /* 把底色改得更淡，让星空更透出来 */
  background: rgba(10, 14, 28, 0.05) !important;
  backdrop-filter: blur(0.4vmin) !important;
  -webkit-backdrop-filter: blur(0.4vmin) !important;

  /* 阴影也稍微减弱一点，避免整块看起来太"沉" */
  box-shadow:
    0 0.8vmin 2vmin rgba(0, 0, 0, 0.2),
    0 0 2vmin rgba(160, 180, 255, 0.15) !important;
}

.transparent::before {
  content: "";
  position: absolute;
  inset: 0;              /* 保持这句，避免右侧"长出来" */
  border-radius: inherit;

  /* 把内部柔光改得更轻、更偏蓝紫一点 */
  background: radial-gradient(
    circle at 20% 0%,
    rgba(210, 230, 255, 0.06),
    rgba(120, 150, 255, 0.03) 45%,
    transparent 70%
  );

  filter: blur(1.2vmin);
  z-index: -1;
  pointer-events: none;
}

/* QR弹窗关闭按钮 - 默认隐藏，悬停时显示 */
.qr-close-btn {
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.transparent:hover .qr-close-btn {
  opacity: 1;
  pointer-events: auto;
}

  </style>
</head>

<body>

<audio id="introBGM" preload="auto" crossorigin="anonymous">
    <source src="stage1-1.mp3" type="audio/mpeg">
</audio>
<audio id="titleBGM" preload="auto" crossorigin="anonymous" loop>
    <source src="bgm.mp3" type="audio/mpeg">
</audio>
<audio id="stage1CountdownBGM" preload="auto" crossorigin="anonymous" loop>
    <source src="stage1-3.mp3" type="audio/mpeg">
</audio>
<audio id="stage2BGM" preload="auto" crossorigin="anonymous" loop>
    <source src="stage2.mp3" type="audio/mpeg">
</audio>
<audio id="star1Sound" preload="auto">
    <source src="star1.mp3" type="audio/mpeg">
</audio>
<audio id="star2Sound" preload="auto">
    <source src="star2.mp3" type="audio/mpeg">
</audio>
<audio id="star3Sound" preload="auto">
    <source src="star3.mp3" type="audio/mpeg">
</audio>
<audio id="stage3BGM" preload="auto" crossorigin="anonymous">
    <source src="stage3-1.mp3" type="audio/mpeg">
</audio>
<video id="videoElement" playsinline></video>
<button id="goStage3Btn">▶ 星空へ</button>
<button id="galleryBtn">≡ ギャラリー</button>
<div id="threeContainer"></div>
<canvas id="artCanvas"></canvas>
<canvas id="uiCanvas"></canvas>

<div id="galleryOverlay">
  <button class="closeBtn">閉じる</button>
  <div id="galleryInner"></div>
</div>

<div id="titleOverlay">
  <div id="titleCard">
    <h1>てのひら星座工房</h1>
    <div id="stageSelectButtons">
      <button class="stageSelectBtn" data-stage="1">Stage 1: 星座を描く</button>
      <button class="stageSelectBtn" data-stage="1.5">Stage 1.5: 練習</button>
      <button class="stageSelectBtn" data-stage="2">Stage 2: 絵を描く</button>
      <button class="stageSelectBtn" data-stage="3">Stage 3: 星空ギャラリー</button>
    </div>
  </div>
</div>

<div id="instructionText" style="position:fixed;bottom:15vmin;left:50%;transform:translateX(-50%);z-index:100;font-size:1.2vmin;opacity:0.85;display:block;color:rgba(255,255,255,0.85);text-align:center;">片手を前へ伸ばし、開いたり閉じたりしてみましょう。<br>手を開き続けると、銀河の中へ進んで、ゲームがスタートします。</div>

<div id="warpOverlay" style="position:fixed;inset:0;z-index:90;background:rgba(0,0,0,0.3);display:none;pointer-events:none;transition:opacity 1.5s ease-in-out;"></div>

<div id="warpTextContainer" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:91;display:none;pointer-events:none;width:100%;height:0;"></div>

<div id="tipOverlay">
  <div class="s1-wrap" id="mysticClockwork" style="display: none;">
    <div class="s1-ring-outer"></div>
    
    <svg class="s1-ring-svg" viewBox="0 0 360 360">
      <g style="opacity: 0.6;">
        <path class="svg-circle-path" d="M 180 5 A 140 140 0 0 1 180 355" />
        <path class="svg-circle-path" d="M 180 355 A 140 140 0 0 1 180 5" />
      </g>
    </svg>
    
    <div class="orbit-layer layer-slow" id="layer1"></div>
    <div class="orbit-layer layer-med" id="layer2"></div>
    <div class="orbit-layer layer-fast" id="layer3"></div>

    <div class="s1-text-box">
      <div class="s1-title">星座が完成しました</div>
      <div class="s1-line"></div>
      <div class="s1-desc">あなたの描いた星座は、いま星空でやさしく輝いています。</div>
    </div>
  </div>
  <div id="tipText"></div>
  <img id="penAnimation" src="pen.png" style="display:none;" alt="Pen Animation">
  <img id="hand1Image" src="hand1.PNG" style="display:none;" alt="Hand 1">
  <img id="hand2Image" src="hand2.PNG" style="display:none;" alt="Hand 2">
  <img id="star1Image" src="star1.PNG" style="display:none;" alt="Star 1">
  <img id="star2Image" src="star2.PNG" style="display:none;" alt="Star 2">
  <img id="star3Image" src="star3.PNG" style="display:none;" alt="Star 3">
</div>
<img id="twoHandImage" src="2hand.PNG" style="display:none;" alt="2 Hand">
<div id="fadeOverlay"></div>

<div id="toolOverlay">
  <div class="toolBuoy active" data-tool="pen">
    <svg viewBox="0 0 24 24">
      <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
    </svg>
    <span class="toolLabel">画筆</span>
  </div>
  <div class="toolBuoy" data-tool="eraser">
    <svg viewBox="0 0 24 24">
      <path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83L5.17 20.1c.78.78 2.05.78 2.83 0l11.14-11.14c.78-.78.78-2.05 0-2.83l-2.58-2.58C16.16 3.2 15.65 3 15.14 3z"/>
    </svg>
    <span class="toolLabel">消しゴム</span>
  </div>
  <div class="toolBuoy" data-tool="undo">
    <svg viewBox="0 0 24 24">
      <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
    </svg>
    <span class="toolLabel">戻る</span>
  </div>
</div>

<div id="stage1Hint"></div>

<div id="stage1_5ProgressHint">中央のプログレスバーを長押ししてください</div>

<div id="drawingControlHint"></div>

<div id="stage1_5ProgressBar">
  <div class="p09-target-zone" id="p09-target"></div>
  <div class="p09-bar-wrapper">
    <div class="p09-line-bg"></div>
    <div class="p09-line-fg" id="p09-line"></div>
    
    <div class="p09-dot d1" id="p09-d1"></div>
    <div class="p09-dot d2" id="p09-d2"></div>
    <div class="p09-dot d3" id="p09-d3"></div>
    <div class="p09-dot d4" id="p09-d4"></div>
  </div>
</div>


<div id="stage2Hint"></div>

<div id="stage2TopHint">描き終わったら、両手でそっと押し返すようにすると、星座が星空の奥へと飛んでいきます。</div>

<div id="stage3BoundaryHint">もう一度スワイプするとタイトルの空にもどります</div>

<script>

// 共通
let stage = 0; // 0=title, 1=Stage1, 1.5=Stage1.5(教学), 2=Stage2, 3=Stage3
let lastActivityTime = performance.now();
const INACTIVITY_TIMEOUT = 30000;
let inactivityTimer = null;

// Stage 1 淡入变量
let stage1Opacity = 1.0;
let stage1AppearStart = 0;
let stage1AppearDuration = 1000;

// ==========================================
//  【最终修正版】完全复刻旧版 (No Scaling, Raw Coordinates)
// ==========================================
let particleCall = null; 

// 1. 旧版 Shader (完全原版参数，保留 900.0 透视系数)
const CALL_VS_ORIGINAL = `
  attribute float brightness;
  attribute float size;
  varying float vB;
  void main(){
    vB = brightness;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    float dist = length(mvPosition.xyz);
    // 900.0 是旧版的透视系数，制造强烈的"扑面而来"感
    gl_PointSize = size * (900.0 / max(dist, 1.0)); 
  }
`;

const CALL_FS_ORIGINAL = `
  varying float vB;
  uniform float uTime;
  uniform float uFadeIn; // 淡入透明度（0.0 = 完全透明，1.0 = 完全不透明，但最大限制为0.6）
  void main(){
    vec2 uv = gl_PointCoord - vec2(0.5);
    float d = length(uv);
    if(d > 0.5) discard;
    float core = smoothstep(0.5, 0.0, d);
    float tw = 0.85 + 0.15 * sin(uTime * 10.0);
    float innerGlow = smoothstep(0.3, 0.0, d);
    float outerGlow = smoothstep(0.5, 0.2, d) * 0.4;
    float finalBrightness = (innerGlow + outerGlow) * vB * tw * 1.3;
    // 应用淡入效果（最大透明度限制为60%）
    finalBrightness *= uFadeIn;
    gl_FragColor = vec4(vec3(1.0), finalBrightness);
  }
`;

// 2. 初始化函数
function startParticleCallAnimation(){
  if(particleCall) disposeParticleCallResources();

  const COUNT = 20000; // 恢复 2万个粒子
  
  const positions = new Float32Array(COUNT * 3);
  const velocities = new Float32Array(COUNT * 3);
  const infos      = new Float32Array(COUNT * 2); 
  const brightness = new Float32Array(COUNT);
  const sizes      = new Float32Array(COUNT);
  
  for(let i=0; i<COUNT; i++){
    // 【关键】使用旧版的巨大坐标系: -8000 到 -20000
    const zBase = -8000 - Math.random() * 12000;
    // 广度：3000+
    const spread = 3000 + Math.abs(zBase) * 0.8; 
    
    const r = Math.sqrt(Math.random()) * spread;
    const theta = Math.random() * Math.PI * 2;
    
    positions[i*3]   = r * Math.cos(theta);
    positions[i*3+1] = r * Math.sin(theta);
    positions[i*3+2] = zBase;
    
    // 【新增】给每颗星星一个持续向前（Z轴正向）的速度，营造星际穿越感
    // 速度随深度变化：越远的星星飞得越慢（视差效果）
    const depthFactor = Math.abs(zBase) / 20000;
    // 缓慢巡航速度：5-25 的范围，营造深空漂流感
    const cruiseSpeed = 5 + Math.random() * 8 + depthFactor * 12;
    velocities[i*3] = 0; 
    velocities[i*3+1] = 0; 
    velocities[i*3+2] = cruiseSpeed; // Z轴正向速度（向摄像机飞来）
    
    infos[i*2]   = Math.random();
    
    infos[i*2+1] = 0.03 + Math.random() * 0.06 + depthFactor * 0.04; 
    brightness[i] = 0.6 + Math.random()*0.8 + depthFactor * 0.2;
    sizes[i] = 3.0 + Math.random() * 8.0 + (1.0 - depthFactor) * 4.0;
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(positions,3));
  geo.setAttribute("brightness", new THREE.BufferAttribute(brightness,1));
  geo.setAttribute("size", new THREE.BufferAttribute(sizes,1));
  const mat = new THREE.ShaderMaterial({
    vertexShader: CALL_VS_ORIGINAL,
    fragmentShader: CALL_FS_ORIGINAL,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms:{ 
      uTime:{value:0},
      uFadeIn:{value:0} // 淡入透明度，初始为0（完全透明），最大值为0.6（60%）
    }
  });
  const pts = new THREE.Points(geo,mat);
  
  // 【关键】直接添加到场景，不要 Group，不要缩放
  scene.add(pts);
  
  particleCall = { 
    active: true,
    points: pts, 
    geometry: geo, 
    velocities: velocities, 
    infos: infos, 
    start: performance.now() 
  };
}

function disposeParticleCallResources(){
  if(!particleCall) return;
  scene.remove(particleCall.points);
  if(particleCall.geometry) particleCall.geometry.dispose();
  if(particleCall.points.material) particleCall.points.material.dispose();
  particleCall=null;
}

// 3. 更新函数
let lastFingerTargets = [];
function updateParticleCallAnimation(){
  if(!particleCall || !particleCall.active) return;
  
  const now = performance.now();
  const elapsed = now - particleCall.start;
  const PARTICLE_DURATION = 2500; 
  const progress = Math.min(1, Math.max(0, elapsed / PARTICLE_DURATION));
  
  particleCall.points.material.uniforms.uTime.value = now * 0.001;
  
  // 淡入效果：3秒内从完全透明淡入到60%透明度
  const FADE_IN_DURATION = 3000; // 3秒
  const fadeInProgress = Math.min(1, Math.max(0, elapsed / FADE_IN_DURATION));
  // 最大透明度限制为60%（0.6）
  particleCall.points.material.uniforms.uFadeIn.value = fadeInProgress * 0.6;
  // 获取手指目标 (3D)
  let targets = [];
  if(handsData && handsData.length > 0){
    const tipIds = [4,8,12,20]; 
    for(let hand of handsData){
      for(let id of tipIds){
        let lm = hand[id];
        if(!lm) continue;
        const coords = getScreenCoordinates(lm);
        let x = coords.x;
        let y = coords.y;
        // screenToWorld3D 会基于当前 Z=1200 的相机，正确算出 Z=0 平面的坐标
        targets.push(screenToWorld3D(x, y, 0));
      }
    }
  }
  
  if(targets.length > 0) lastFingerTargets = targets;
  else if(lastFingerTargets.length > 0) targets = lastFingerTargets;
  else targets = [new THREE.Vector3(0,0,0)];
  const pos = particleCall.geometry.attributes.position.array;
  const vel = particleCall.velocities;
  const inf = particleCall.infos;
  const count = particleCall.geometry.attributes.position.count;
  const targetCount = targets.length;
  const ease = progress * progress * progress;
  
  // 【新增】判断是否有手部引力（有手时才吸引，没手时持续巡航）
  const hasHandGravity = targets.length > 0 && targets[0].x !== 0 && targets[0].y !== 0;
  
  for(let i=0; i<count; i++){
    const idx3 = i*3;
    
    // 【新增】无限循环：星星飞过摄像机后，重置到远处
    // 摄像机在 Z=1200，星星飞过 Z=2000 时重置
    if(pos[idx3+2] > 2000) {
      // 重置到极远处（-15000 到 -20000）
      const newZ = -15000 - Math.random() * 5000;
      const spread = 3000 + Math.abs(newZ) * 0.8;
      const r = Math.sqrt(Math.random()) * spread;
      const theta = Math.random() * Math.PI * 2;
      
      pos[idx3]   = r * Math.cos(theta);
      pos[idx3+1] = r * Math.sin(theta);
      pos[idx3+2] = newZ;
      
      // 重新设置巡航速度（与初始化保持一致）
      const depthFactor = Math.abs(newZ) / 20000;
      const cruiseSpeed = 5 + Math.random() * 8 + depthFactor * 12;
      vel[idx3] = 0;
      vel[idx3+1] = 0;
      vel[idx3+2] = cruiseSpeed;
      continue;
    }
    
    // 【修改】只有在有手部引力时才执行吸引逻辑
    if(hasHandGravity) {
      const tIdx = i % targetCount;
      const target = targets[tIdx];
      
      const dx = target.x - pos[idx3];
      const dy = target.y - pos[idx3+1];
      const dz = target.z - pos[idx3+2];
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      
      const speedFactor = inf[i*2+1];
      
      // 距离越远，吸力越强 (恢复旧版逻辑)
      const distanceFactor = Math.min(1.0, dist / 5000.0);
      const gravityBoost = 1.0 + distanceFactor * 2.5;
      
      if (progress > 0.85) {
          const lerpFactor = 0.15 + (progress - 0.85) * 6.0; 
          pos[idx3]   += dx * lerpFactor;
          pos[idx3+1] += dy * lerpFactor;
          pos[idx3+2] += dz * lerpFactor;
      } else {
          const baseSuction = 0.0015;
          const progressSuction = ease * 0.025;
          const suction = (baseSuction + progressSuction) * gravityBoost;
          
          // 手部引力会覆盖巡航速度
          vel[idx3]   += dx * suction * speedFactor;
          vel[idx3+1] += dy * suction * speedFactor;
          vel[idx3+2] += dz * suction * speedFactor;
          
          const damping = 0.91 - ease * 0.05;
          vel[idx3]   *= damping;
          vel[idx3+1] *= damping;
          vel[idx3+2] *= damping;
          
          pos[idx3]   += vel[idx3];
          pos[idx3+1] += vel[idx3+1];
          pos[idx3+2] += vel[idx3+2];
      }
    } else {
      // 【新增】没有手部引力时，保持巡航模式（持续向前飞行）
      // 逐渐恢复巡航速度（如果被手部引力干扰过）
      const depthFactor = Math.abs(pos[idx3+2]) / 20000;
      const targetCruiseSpeed = 5 + depthFactor * 12;
      
      // 平滑过渡到巡航速度
      if(Math.abs(vel[idx3+2] - targetCruiseSpeed) > 0.5) {
        vel[idx3+2] += (targetCruiseSpeed - vel[idx3+2]) * 0.02;
      }
      
      // XY方向的速度逐渐衰减（回归直线飞行）
      vel[idx3] *= 0.98;
      vel[idx3+1] *= 0.98;
      
      // 添加微小的随机扰动，让飞行更自然（模拟星际尘埃的影响）
      const turbulence = 0.3;
      vel[idx3] += (Math.random() - 0.5) * turbulence;
      vel[idx3+1] += (Math.random() - 0.5) * turbulence;
      
      pos[idx3]   += vel[idx3];
      pos[idx3+1] += vel[idx3+1];
      pos[idx3+2] += vel[idx3+2];
    }
  }
  
  particleCall.geometry.attributes.position.needsUpdate = true;
}

// 坐标转换：2D 屏幕坐标转 3D 世界坐标
function screenToWorld3D(screenX, screenY, depth = 0) {
    // 将屏幕坐标转换为 NDC (Normalized Device Coordinates)
    const x = (screenX / W) * 2 - 1;
    const y = -(screenY / H) * 2 + 1;
    
    // 创建向量并反投影到世界空间
    const vector = new THREE.Vector3(x, y, 0.5);
    vector.unproject(camera);
    
    // 计算从相机到目标点的方向
    const dir = new THREE.Vector3().subVectors(vector, camera.position).normalize();
    
    // 使用相机的 z 位置作为基准深度，加上偏移
    const distance = Math.abs(camera.position.z) + depth;
    return camera.position.clone().add(dir.multiplyScalar(distance));
}


function updateActivityTime() {
    lastActivityTime = performance.now();
    if (inactivityTimer) clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(() => {
        // 自动返回 Stage0，不刷新页面以避免重复请求摄像头权限
        if (stage !== 0) enterStage0();
    }, INACTIVITY_TIMEOUT);
}

// 完全重新初始化标题界面（与页面首次加载时完全一致）
function enterStage0(isFromReturn = false){
  // 1. 停止所有BGM
  const introBGM = document.getElementById("introBGM");
  if (introBGM) {
    introBGM.pause();
    introBGM.currentTime = 0;
  }
  const stage1CountdownBGM = document.getElementById("stage1CountdownBGM");
  if (stage1CountdownBGM) {
    stage1CountdownBGM.pause();
    stage1CountdownBGM.currentTime = 0;
  }
  const stage2BGM = document.getElementById("stage2BGM");
  if (stage2BGM) {
    stage2BGM.pause();
    stage2BGM.currentTime = 0;
  }
  const stage3BGM = document.getElementById("stage3BGM");
  if (stage3BGM) {
    stage3BGM.pause();
    stage3BGM.currentTime = 0;
  }
  
  // 2. 清理旧的星空背景对象（dispose geometry/material）
  if(titleGalaxyParticles) {
    scene.remove(titleGalaxyParticles);
    if(titleGalaxyParticles.geometry) titleGalaxyParticles.geometry.dispose();
    if(titleGalaxyParticles.material) {
      if(titleGalaxyParticles.material.map) titleGalaxyParticles.material.map.dispose();
      titleGalaxyParticles.material.dispose();
    }
    titleGalaxyParticles = null;
  }
  if(titleOuterGalaxyParticles) {
    scene.remove(titleOuterGalaxyParticles);
    if(titleOuterGalaxyParticles.geometry) titleOuterGalaxyParticles.geometry.dispose();
    if(titleOuterGalaxyParticles.material) {
      if(titleOuterGalaxyParticles.material.map) titleOuterGalaxyParticles.material.map.dispose();
      titleOuterGalaxyParticles.material.dispose();
    }
    titleOuterGalaxyParticles = null;
  }
  if(titleNebulaBackground) {
    scene.remove(titleNebulaBackground);
    if(titleNebulaBackground.geometry) titleNebulaBackground.geometry.dispose();
    if(titleNebulaBackground.material) titleNebulaBackground.material.dispose();
    titleNebulaBackground = null;
  }
  if(titleGalacticCore) {
    scene.remove(titleGalacticCore);
    if(titleGalacticCore.children) {
      titleGalacticCore.children.forEach(child => {
        if(child.geometry) child.geometry.dispose();
        if(child.material) child.material.dispose();
      });
    }
    titleGalacticCore = null;
  }
  if(titleDeepStars) {
    scene.remove(titleDeepStars);
    if(titleDeepStars.geometry) titleDeepStars.geometry.dispose();
    if(titleDeepStars.material) titleDeepStars.material.dispose();
    titleDeepStars = null;
  }
  
  // 3. 清理 shadowConstellation（如果有）
  if(shadowConstellation) {
    scene.remove(shadowConstellation);
    if(shadowConstellation.traverse) {
      shadowConstellation.traverse(obj => {
        if(obj.geometry) obj.geometry.dispose();
        if(obj.material) {
          if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
          else if(obj.material.dispose) obj.material.dispose();
        }
      });
    }
    shadowConstellation = null;
  }
  
  // 4. 清理 3D 锁定星星（如果有）
  if(lockedFingerStars){
    scene.remove(lockedFingerStars.group);
    if(lockedFingerStars.geo) lockedFingerStars.geo.dispose();
    if(lockedFingerStars.mat) lockedFingerStars.mat.dispose();
    lockedFingerStars = null;
  }
  
  // 清理 Stage1 粒子特效
  disposeParticleCallResources();
  
  // 5. 清理场景中所有用户创建的对象
  for(let i = 0; i < creations.length; i++){
    const rec = creations[i];
    if(rec.group){
      if(rec.group.parent) rec.group.parent.remove(rec.group);
      if(rec.group.traverse){
        rec.group.traverse(obj => {
          if(obj.geometry) obj.geometry.dispose();
          if(obj.material) {
            if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
            else if(obj.material.dispose) obj.material.dispose();
          }
        });
      }
      rec.group = null;
    }
  }
  creations = [];
  
  // 6. 兜底清理场景中其他临时对象
  const objectsToRemove = [];
  for(let i = scene.children.length - 1; i >= 0; i--){
    const child = scene.children[i];
    if(child instanceof THREE.Group){
      const isUserCreation = child.userData && child.userData.isUserCreation === true;
      const isInConstellationRange = child.position.z >= -2500 && child.position.z <= -1000;
      if(isUserCreation || isInConstellationRange){
        objectsToRemove.push(child);
      }
    }
  }
  objectsToRemove.forEach(obj => {
    if(obj && obj.parent) {
      obj.parent.remove(obj);
      if(obj.traverse) {
        obj.traverse(child => {
          if(child.geometry) child.geometry.dispose();
          if(child.material) {
            if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
            else if(child.material.dispose) child.material.dispose();
          }
        });
      }
    }
  });
  
  // 7. 重新初始化星空背景（与页面首次加载时完全一样）
  initTitleBackground();
  
  // 8. 重置 shader uniforms（uTime 等）
  if(titleNebulaBackground && titleNebulaBackground.userData && titleNebulaBackground.userData.uniforms) {
    titleNebulaBackground.userData.uniforms.uTime.value = 0;
  }
  lastTitleBackgroundTime = performance.now();
  
  // 9. 重置手势数据（不重新启动摄像头或 MediaPipe，避免重复请求权限）
  handsData = [];
  
  // 10. 重置全局变量
  stage = 0;
  stage2Warping = false;
  stage2HandInitialDist = null;
  stage2PushFrames = 0;
  stage1TipSequenceState = "waiting";
  stage1GestureDetectionStartTime = 0;
  if(stage1TipSequenceTimer) {
    clearTimeout(stage1TipSequenceTimer);
    stage1TipSequenceTimer = null;
  }
  RIGHT_BOUNDARY.isAtBoundary = false;
  RIGHT_BOUNDARY.isBouncing = false;
  
  // 重置相机位置和状态
  camera.position.set(0, 0, 24);
  camera.fov = 60;
  camera.updateProjectionMatrix();
  camTargetX = 0;
  camTargetY = 0;
  camTargetZ = 24;
  
  // 重置标题界面状态
  titleCameraZ = 24;
  titleCameraTargetZ = 24;
  titleWarpSpeed = 0;
  targetTitleWarpSpeed = 0;
  titleGalaxyRotationSpeed = 0.033;
  titleTargetRotationSpeed = 0.033;
  titleHandWasFist = false;
  titleHandWasOpen = false;
  fistFrameCount = 0; // 重置握拳检测缓冲
  
  // 重置穿越文字状态
  warpTextState.isActive = false;
  warpTextState.currentLineIndex = 0;
  warpTextState.currentCharIndex = 0;
  warpTextState.autoMoving = false;
  
  // 重置绘图相关变量
  prevPts = null;
  stillFrames = 0;
  savedPolygonGlobal = null;
  savedConstellationEdges = null;
  strokePolylines = [];
  currentStrokePath = null;
  penHist = [];
  lastPen = null;
  pinching = false;
  stage1StartTime = 0;
  lastSecondPolygon = null;
  stage1Opacity = 1.0;
  stage1AppearStart = 0;
  stage1AppearDuration = 1000;
  
  // 隐藏手部图片
  const hand1Image = document.getElementById("hand1Image");
  const hand2Image = document.getElementById("hand2Image");
  const twoHandImage = document.getElementById("twoHandImage");
  if(hand1Image) {
    hand1Image.classList.remove("visible");
    hand1Image.style.display = "none";
  }
  if(hand2Image) {
    hand2Image.classList.remove("visible");
    hand2Image.style.display = "none";
  }
  if(twoHandImage) {
    twoHandImage.classList.remove("visible");
    twoHandImage.style.display = "none";
  }
  
  // 隐藏star图片
  const star1Image = document.getElementById("star1Image");
  const star2Image = document.getElementById("star2Image");
  const star3Image = document.getElementById("star3Image");
  if(star1Image) {
    star1Image.classList.remove("visible");
    star1Image.style.display = "none";
  }
  if(star2Image) {
    star2Image.classList.remove("visible");
    star2Image.style.display = "none";
  }
  if(star3Image) {
    star3Image.classList.remove("visible");
    star3Image.style.display = "none";
  }
  
  // 清除star图片序列定时器
  if(starImageSequenceTimer) {
    clearTimeout(starImageSequenceTimer);
    starImageSequenceTimer = null;
  }
  
  // 重置 Stage1.5 状态
  stage1_5State = "waitingPinch";
  stage1_5LineDrawn = false;
  stage1_5StateChangeTime = 0;
  stage1_5ProgressBarHolding = false;
  stage1_5ProgressBarHoldStart = 0;
  stage1_5ProgressBarLastValidTime = 0;
  
  // 停止 Pen 动画
  stopPenAnimation();
  
  // 重置 Stage2 状态
  stage2PushInitialDist = null;
  stage2PushMinDist = null;
  stage2PushDetectionStartTime = 0;
  stage2LastPos = null;
  stage2LastTime = null;
  stage2WarpStart = 0;
  stage2WarpDuration = 2000; // 【恢复旧版】改为 2000ms
  stage2WarpStartZ = 0;
  stage2WarpTargetZ = -15000;
  
  // 清除画布
  artCtx.clearRect(0, 0, W, H);
  uiCtx.clearRect(0, 0, W, H);
  inkCtx.clearRect(0, 0, W, H);
  artCanvasDirty = false;
  
  // 11. 重置 UI 状态
  // 隐藏穿越文字相关元素
  const warpOverlay = document.getElementById("warpOverlay");
  const warpTextContainer = document.getElementById("warpTextContainer");
  if(warpOverlay) {
    warpOverlay.style.display = "none";
    warpOverlay.style.opacity = "";
  }
  if(warpTextContainer) {
    warpTextContainer.innerHTML = "";
    warpTextContainer.style.display = "none";
  }
  
  // 显示标题覆盖层（恢复初始状态）
  const titleOverlay = document.getElementById("titleOverlay");
  if(titleOverlay){
    titleOverlay.style.display = "flex";
    titleOverlay.style.opacity = "";
    titleOverlay.style.transition = "";
  }
  
  // 显示提示文字（恢复初始状态）
  const instructionText = document.getElementById("instructionText");
  if(instructionText) {
    instructionText.style.display = "block";
    instructionText.style.opacity = "0.85";
    instructionText.style.transition = "";
  }
  
  // 隐藏所有其他UI元素
  document.getElementById("goStage3Btn").style.display = "none";
  document.getElementById("galleryBtn").style.display = "none";
  const stage1Hint = document.getElementById("stage1Hint");
  if(stage1Hint) {
    stage1Hint.classList.remove("visible");
    stage1Hint.style.display = "none";
  }
  const stage2Hint = document.getElementById("stage2Hint");
  if(stage2Hint) {
    stage2Hint.classList.remove("visible");
    stage2Hint.style.display = "none";
  }
  const stage2TopHint = document.getElementById("stage2TopHint");
  if(stage2TopHint) {
    stage2TopHint.classList.remove("visible");
    stage2TopHint.style.display = "none";
  }
  const stage3BoundaryHint = document.getElementById("stage3BoundaryHint");
  if(stage3BoundaryHint) {
    stage3BoundaryHint.style.display = "none";
  }
  
  // 隐藏绘画控制小标语
  const drawingControlHint = document.getElementById("drawingControlHint");
  if(drawingControlHint) {
    drawingControlHint.classList.remove("visible");
    drawingControlHint.style.display = "none";
  }
  
  // 隐藏画布
  artCanvas.style.display = "none";
  uiCanvas.style.display = "none";
  
  // 隐藏视频背景
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.remove("stage1Visible");
  }
  
  // 隐藏进度条相关元素
  const progressHint = document.getElementById("stage1_5ProgressHint");
  const progressBar = document.getElementById("stage1_5ProgressBar");
  if(progressHint) {
    progressHint.classList.remove("visible");
    progressHint.style.display = "none";
  }
  if(progressBar) {
    progressBar.classList.remove("visible");
    progressBar.style.display = "none";
    // 重置进度条 UI
    const line = document.getElementById("p09-line");
    if(line) line.style.width = "0%";
    const dots = document.querySelectorAll(".p09-dot");
    dots.forEach(d => d.classList.remove("active"));
    const targetZone = document.getElementById("p09-target");
    if(targetZone) targetZone.classList.remove("active");
  }
  
  // 12. 重新播放标题BGM
  const titleBGM = document.getElementById("titleBGM");
  if (titleBGM) {
    titleBGM.currentTime = 0;
    titleBGM.volume = 1.0;
    titleBGM.play().catch(e => console.log("标题BGM播放失败:", e));
  }
  
  // 13. 重新初始化星尘粒子系统（initStars）
  // 清除旧的星星层
  const starLayers = ['layer1', 'layer2', 'layer3'];
  starLayers.forEach(layerId => {
    const layer = document.getElementById(layerId);
    if(layer) {
      layer.innerHTML = '';
    }
  });
  // 重新初始化
  initStars();
  
  // 14. 清除倒计时（返回标题界面时不需要倒计时）
  if (inactivityTimer) {
    clearTimeout(inactivityTimer);
    inactivityTimer = null;
  }
  
  // 15. 渲染一次确保状态正确
  renderer.render(scene, camera);
}

function returnToTitle(){
  // 统一调用 enterStage0 进行完整重置
  enterStage0(true);
  // 重新启动 MediaPipe 摄像头与手势识别
  initHands();
}

let warpAmplifier = 1.0;

//   标题界面：穿越文字显示
const WARP_TEXT_MESSAGES = [
  "ようこそ",
  "ここは、宇宙のはじっこで、星と星がつながって星座になるところ――星座工房。",
  "かつて人々が、夜空を見上げて，星の点という小さな形から、いろいろなかたちや物語を生み出しました。",
  "ここでは、あなたの手が、星たちに新しい物語をあたえていきます。",
  "まずは、あなたの最初の星座をつくってみましょう。"
];

// 每句标语的停顿间隔时间（毫秒），对应 WARP_TEXT_MESSAGES 数组的索引
// 例如：[第0句后等待时间, 第1句后等待时间, 第2句后等待时间, ...]
const LINE_INTERVALS = [
  1000,  // "ようこそ" 后等待 1.5秒
  1500,  // 第2句后等待 2秒
  1500,  // 第3句后等待 1.8秒
  1500,  // 第4句后等待 2.5秒
  1500   // 最后一句后等待 2秒（进入stage1前的等待）
];

let warpTextState = {
  isActive: false,
  currentLineIndex: 0,
  currentCharIndex: 0,
  lastUpdateTime: 0,
  charInterval: 80,
  lineInterval: 2000,  // 保留作为默认值（如果数组未定义时使用）
  triggerZRange: [-15, 0],
  autoMoving: false,
  autoMoveSpeed: -0.15
};
let titleWarpSpeed = 0;
let targetTitleWarpSpeed = 0;
let titleCameraZ = 24;
let titleCameraTargetZ = 24;
let titleGalaxyRotationSpeed = 0.033;
let titleTargetRotationSpeed = 0.033;

// 标题手势状态
let titleHandWasFist = false;
let titleHandWasOpen = false;
let fistFrameCount = 0; // 握拳检测缓冲帧计数

let stage2Warping = false;
let stage2WarpStart = 0;
let stage2WarpDuration = 2000; // 【恢复旧版】改为 2000ms
let stage2WarpStartZ = 0;
let stage2WarpTargetZ = -15000;
let stage2HandInitialDist = null;
let stage2PushFrames = 0;

let W = window.innerWidth;
let H = window.innerHeight;

// 艺术层 Canvas：显示已完成的绘画
const artCanvas = document.getElementById("artCanvas");
artCanvas.width = W;
artCanvas.height = H;
const artCtx = artCanvas.getContext("2d");

// UI 层 Canvas：高频交互元素（光标、进度条等）
const uiCanvas = document.getElementById("uiCanvas");
uiCanvas.width = W;
uiCanvas.height = H;
const uiCtx = uiCanvas.getContext("2d");


function mirrorX(x){ return W - x; }
function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

// 计算摄像头画面在屏幕上的实际缩放比例和偏移量
// 模拟 object-fit: cover 的逻辑来计算坐标，解决宽高比失调问题
function getScreenCoordinates(landmark) {
  const video = document.getElementById("videoElement");
  if (!video || !video.videoWidth) {
    // 降级处理：如果没有视频数据，回退到原来的简单拉伸
    return { x: mirrorX(landmark.x * W), y: landmark.y * H };
  }

  const vidW = video.videoWidth;
  const vidH = video.videoHeight;
  const screenW = W;
  const screenH = H;

  // 模拟 object-fit: cover 的逻辑
  const scale = Math.max(screenW / vidW, screenH / vidH);
  
  // 计算视频在屏幕上居中后的偏移量
  const scaledW = vidW * scale;
  const scaledH = vidH * scale;
  const offsetX = (scaledW - screenW) / 2;
  const offsetY = (scaledH - screenH) / 2;

  // 1. 将 0-1 的 landmark 坐标映射到 缩放后的视频尺寸
  // 2. 减去偏移量，使其对齐屏幕中心
  let rawX = landmark.x * scaledW - offsetX;
  let rawY = landmark.y * scaledH - offsetY;

  // 3. 镜像处理 (Mirror)
  // MediaPipe 输出的 x 是从左到右 (0->1)。镜像要在映射后翻转。
  let finalX = screenW - rawX; 
  
  return { x: finalX, y: rawY };
}

// 标准化星座形状：居中并调整大小
function normalizeConstellation(points) {
  if(!points || points.length === 0) return points;
  
  // 计算包围盒
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  
  for(let p of points) {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }
  
  // 计算包围盒的中心点和尺寸
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const width = maxX - minX;
  const height = maxY - minY;
  
  if(width === 0 && height === 0) return points.map(p => ({...p}));
  
  // === 智能缩放逻辑 ===
  const currentSize = Math.max(width, height); // 当前星座的最大边长
  const screenSize = Math.min(W, H);           // 屏幕的最短边
  const ratio = currentSize / screenSize;      // 当前占比
  
  const MIN_RATIO = 0.35; // 最小占比 35%
  const MAX_RATIO = 0.85; // 最大占比 85%
  
  let scale = 1.0; // 默认不缩放
  
  if (ratio < MIN_RATIO) {
    // 太小了：放大到最小安全尺寸
    scale = (screenSize * MIN_RATIO) / currentSize;
  } else if (ratio > MAX_RATIO) {
    // 太大了：缩小到最大限制尺寸
    scale = (screenSize * MAX_RATIO) / currentSize;
  }
  // 如果在 0.35 ~ 0.85 之间，保持 scale = 1.0 (原样大小)
  
  // === 始终居中 ===
  const targetCenterX = W / 2;
  const targetCenterY = H / 2;
  
  return points.map(p => ({
    x: (p.x - cx) * scale + targetCenterX,
    y: (p.y - cy) * scale + targetCenterY
  }));
}

const FADE_DURATION = 800;
const TIP_FADE_DURATION = 600;

// Stage1：双手轮廓
let prevPts=null;
let stillFrames=0;
const STILL_REQUIRED=180; // 用于动画效果
let savedPolygonGlobal=null;
let stage1StartTime=0; // Stage1 开始时间
const STAGE1_DURATION=10000; // 10秒后自动进入 Stage1.5
let lastSecondPolygon=null; // 最后一秒时的星座形状
let latestValidPolygon=null; // 最近一次有效的星座形状

// Stage1 标语序列状态
let stage1TipSequenceState = "waiting"; // waiting, showingTip1, showingTip2, waitingGesture, showingTip3, completed
let stage1TipSequenceTimer = null;
let stage1GestureDetectionStartTime = 0; // 手势识别开始时间
const STAGE1_TIP_DISPLAY_DURATION = 6000; // 每个标语显示6秒
const STAGE1_GESTURE_DETECTION_DURATION = 10000; // 手势识别等待10秒

//   Stage1.5：绘画教学
let stage1_5State = "waitingPinch"; // waitingPinch, drawing, waitingRelease, complete, progressBar
let stage1_5LineDrawn = false;
let stage1_5StateChangeTime = 0;
let stage1_5ProgressBarHolding = false;
let stage1_5ProgressBarHoldStart = 0;
let stage1_5TipLastUpdate = 0; // 标语最后更新时间（用于 cooldown）
let stage1_5TipUpdateTimer = null; // 标语更新定时器（用于淡出淡入动画）
let stage1_5TipCooldown = 2000; // 标语切换 cooldown 时间（2秒）
const STAGE1_5_PROGRESS_DURATION = 3000; // 3秒

// Stage1.5 状态（已由 stage1_5State 统一管理，不再需要单独的标语序列状态）
let penAnimationTimer = null; // Pen 动画循环定时器
let penHideTimer = null; // Pen 动画隐藏定时器
let stage1_5EntryTime = 0; // 用于安全缓冲期

// 保存星座连线结构（拓扑），防止缩放后连线改变
let savedConstellationEdges = null;

// Stage2 到 Stage3 的手势检测状态（两手推开）
let stage2PushInitialDist = null; // 两手推开的初始距离
let stage2PushMinDist = null; // 两手推开过程中的最小距离（用于检测是否持续推开）
const STAGE2_PUSH_REQUIRED_DISTANCE = 150; // 需要推开的最小距离（像素）
let stage2PushDetectionStartTime = 0; // 开始检测推开的时间
const STAGE2_PUSH_DETECTION_TIMEOUT = 5000; // 检测超时时间（5秒）

// Stage1.5 进度条容错状态
let stage1_5ProgressBarLastValidTime = 0; // 最后一次有效检测的时间
const STAGE1_5_PROGRESS_GRACE_PERIOD = 300; // 宽限期（毫秒），允许短暂离开或松开

// Stage2 画笔误触检测状态
let stage2LastPos = null; // 上一帧的位置
let stage2LastTime = null; // 上一帧的时间
const STAGE2_MAX_SPEED = 9000; // 最大允许速度（像素/秒）
const STAGE2_MAX_JUMP_DIST = 400; // 最大允许位置瞬移距离（像素）

// Stage1.5 画笔误触检测状态（与 Stage2 使用相同的检测逻辑）
let stage1_5LastPos = null; // 上一帧的位置
let stage1_5LastTime = null; // 上一帧的时间
const STAGE1_5_MAX_SPEED = 9000; // 最大允许速度（像素/秒）
const STAGE1_5_MAX_JUMP_DIST = 400; // 最大允许位置瞬移距离（像素）

// 提取连线算法为独立函数，供stage1和stage3共用
function computeConstellationEdges(pts, maxDistance = null){
  if(!pts || pts.length < 2) return [];

  const n = pts.length;
  const edges = [];
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const dx = pts[j].x - pts[i].x;
      const dy = pts[j].y - pts[i].y;
      const d = Math.hypot(dx,dy);
      edges.push({i,j,dist:d});
    }
  }

  const leftIdx = [0,1,2,3];
  const rightIdx = [4,5,6,7];
  const lr = [];
  for(let li of leftIdx){
    for(let ri of rightIdx){
      if(li>=n || ri>=n) continue;
      const dx = pts[ri].x - pts[li].x;
      const dy = pts[ri].y - pts[li].y;
      lr.push({i:li, j:ri, dist: Math.hypot(dx,dy)});
    }
  }
  lr.sort((a,b)=>a.dist-b.dist);
  // 只允许连接最近的 1-2 条线，避免过多的长距离连线
  const BRIDGE_COUNT = Math.min(2, lr.length);
  const bridgeEdges = lr.slice(0, BRIDGE_COUNT);

  const parent = new Array(n);
  for(let i=0;i<n;i++) parent[i]=i;
  const find=x=>parent[x]===x?x:(parent[x]=find(parent[x]));
  const unite=(a,b)=>{ parent[find(a)] = find(b); };

  const chosen = [];
  const usedPairs = new Set();

  for(const b of bridgeEdges){
    chosen.push(b);
    unite(b.i,b.j);
    usedPairs.add(`${b.i}-${b.j}`);
  }

  edges.sort((a,b)=>a.dist-b.dist);
  for(const e of edges){
    if(find(e.i)!==find(e.j)){
      unite(e.i,e.j);
      chosen.push(e);
      usedPairs.add(`${e.i}-${e.j}`);
    }
  }

  const EXTRA_MAX = 10;
  const MAX_DEGREE = 6;
  // 1. 设置一个更合理的上限。在大屏上，我们希望星星只和"附近"的连，而不是跨越半个屏幕去连。
  // 我们可以限制最大连接距离为屏幕宽度的 6%~8%，或者设置一个像素上限（例如 300px）。
  const baseDist = Math.max(W, H) * 0.08; // 降低比例系数 (0.12 -> 0.08)
  // 2. 增加一个绝对像素限制 (例如在4K屏上也不要超过 350px)
  const cappedDist = Math.min(baseDist, 350);
  const EXTRA_MAX_DIST = maxDistance || cappedDist;
  const degree = new Array(n).fill(0);
  for(const e of chosen){ degree[e.i]++; degree[e.j]++; }

  let extraAdded=0;
  for(const e of edges){
    if(extraAdded>=EXTRA_MAX) break;
    const key=`${e.i}-${e.j}`;
    if(usedPairs.has(key)) continue;
    if(degree[e.i]>=MAX_DEGREE || degree[e.j]>=MAX_DEGREE) continue;
    if(e.dist>EXTRA_MAX_DIST) continue;
    chosen.push(e);
    usedPairs.add(key);
    degree[e.i]++; degree[e.j]++;
    extraAdded++;
  }

  return chosen;
}

function drawStage1Polyline(pts, targetCtx = null, forcedEdges = null){
  if(!pts || pts.length < 2) return;
  // 如果没有指定 context，默认使用 artCtx（向后兼容）
  const c = targetCtx || artCtx;

  // 【修改点】如果有强制连线数据，直接使用；否则才重新计算
  const chosen = forcedEdges || computeConstellationEdges(pts);

  const g = c.createRadialGradient(W/2, H/2, W*0.05, W/2, H/2, W*0.8);
  g.addColorStop(0, "rgba(90,140,255,0.07)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  c.fillStyle = g;
  c.fillRect(0,0,W,H);

  c.save();
  c.lineCap="round";
  c.lineJoin="round";

  c.lineWidth = 4.5; // 从 4.5 放大到 6.75 (1.5倍)
  c.strokeStyle = "rgba(255,255,255,0.28)";
  for(const e of chosen){
    const p1=pts[e.i], p2=pts[e.j];
    c.beginPath();
    c.moveTo(p1.x,p1.y);
    c.lineTo(p2.x,p2.y);
    c.stroke();
  }

  c.lineWidth = 1.2; // 从 1.2 放大到 1.8 (1.5倍)
  c.strokeStyle = "rgba(255,255,255,0.85)";
  for(const e of chosen){
    const p1=pts[e.i], p2=pts[e.j];
    c.beginPath();
    c.moveTo(p1.x,p1.y);
    c.lineTo(p2.x,p2.y);
    c.stroke();
  }

  for(const e of chosen){
    const p1=pts[e.i], p2=pts[e.j];
    const dx=p2.x-p1.x, dy=p2.y-p1.y;
    const len=Math.hypot(dx,dy);
    const starCount = Math.max(1, Math.floor(len/60));
    for(let s=0;s<starCount;s++){
      if(Math.random()<0.7) continue;
      const t = Math.random();
      const px = p1.x + dx*t + (Math.random()*6-3);
      const py = p1.y + dy*t + (Math.random()*6-3);
      const a = 0.25 + Math.random()*0.45;
      c.fillStyle = `rgba(255,255,255,${a})`;
      c.beginPath();
      c.arc(px,py,2.25,0,Math.PI*2); // 从 1.5 放大到 2.25 (1.5倍)
      c.fill();
    }
  }

  c.restore();

  for(let p of pts){
    c.beginPath();
    c.arc(p.x,p.y,21,0,Math.PI*2); // 从 14 放大到 21 (1.5倍)
    c.fillStyle = "rgba(160,200,255,0.08)";
    c.fill();

    c.beginPath();
    c.arc(p.x,p.y,12,0,Math.PI*2); // 从 8 放大到 12 (1.5倍)
    c.fillStyle = "rgba(220,240,255,0.28)";
    c.fill();

    c.beginPath();
    c.arc(p.x,p.y,5.4,0,Math.PI*2); // 从 3.6 放大到 5.4 (1.5倍)
    c.fillStyle = "#ffffff";
    c.fill();
  }

  if(stillFrames > STILL_REQUIRED * 0.6){
    const t = (stillFrames / STILL_REQUIRED);
    const pulse = Math.sin(t * Math.PI) * 0.3;
    c.save();
    c.globalCompositeOperation="lighter";
    c.fillStyle = `rgba(200,220,255,${pulse*0.15})`;
    c.fillRect(0,0,W,H);
    c.restore();
  }
}

function doStage1(){
  // UI 层：每一帧清除并重绘实时连线
  uiCtx.clearRect(0,0,W,H);
  // 艺术层：Stage1 阶段不需要清除（没有已完成的绘画）

  // 显示实时视频背景（仅在 stage1 显示）
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.add("stage1Visible");
  }

  // 检查手势识别并显示标语3（从标语2显示时就开始检测）
  if(stage1TipSequenceState === "waitingGesture" || stage1TipSequenceState === "showingTip2") {
    checkGestureAndShowTip3();
  }

  // 核心：每一帧更新聚集动画
  updateParticleCallAnimation();

  // 如果标语序列未完成，不开始倒计时，但允许绘制手势连线（从标语2开始）
  if(stage1TipSequenceState !== "completed") {
    // 从标语2开始，允许绘制手势连线（包括标语3出现期间）
    if(stage1TipSequenceState === "showingTip2" || stage1TipSequenceState === "waitingGesture" || stage1TipSequenceState === "showingTip3") {
      // 允许绘制手势连线，但不显示倒计时提示
      if(handsData.length >= 2) {
        let A=handsData[0], B=handsData[1];
        let left  = A[0].x < B[0].x ? A : B;
        let right = (left===A)? B : A;
        const ids=[4,8,12,20];
        let pts=[];
        for(let i of ids) pts.push(getScreenCoordinates(left[i]));
        for(let i of ids) pts.push(getScreenCoordinates(right[i]));
        
        // 实时连线绘制到 UI 层
        drawStage1Polyline(pts, uiCtx);
        latestValidPolygon = pts.map(p=>({...p}));
        updateActivityTime();
      }
    }
    return;
  }

  // 初始化 Stage1 开始时间（标语序列完成后）
  if(stage1StartTime === 0){
    stage1StartTime = performance.now();
    
    // 开始播放Stage1倒计时BGM
    const stage1CountdownBGM = document.getElementById("stage1CountdownBGM");
    if (stage1CountdownBGM) {
      stage1CountdownBGM.currentTime = 0;
      stage1CountdownBGM.volume = 0.7; // 音量70%
      stage1CountdownBGM.play().catch(e => console.log("Stage1倒计时BGM播放失败:", e));
    }
  }

  // 显示提示元素（渐变出现）
  const stage1Hint = document.getElementById("stage1Hint");
  if(stage1Hint) {
    stage1Hint.style.display = "block";
    // 使用requestAnimationFrame确保display:block后再添加visible类
    requestAnimationFrame(() => {
      stage1Hint.classList.add("visible");
    });
  }

  // 淡入逻辑：根据 stage1Opacity 控制透明度（UI 层）
  if (stage === 1 && stage1Opacity < 1) {
    const t = (performance.now() - stage1AppearStart) / stage1AppearDuration;
    stage1Opacity = Math.min(1, t);
    uiCtx.save();
    uiCtx.globalAlpha = stage1Opacity;
  } else {
    uiCtx.save();
  }

  // 计算已过时间
  const elapsed = performance.now() - stage1StartTime;
  const remaining = Math.max(0, STAGE1_DURATION - elapsed);
  const remainingSeconds = Math.ceil(remaining / 1000);

  if(handsData.length<2){
    prevPts=null;
    // 更新提示文字：显示倒计时
    if(stage1Hint) {
      if(remainingSeconds > 0) {
        stage1Hint.innerHTML = "10秒後に自動的に次の段階に進みます<br><span class='countdown-text'>残り " + remainingSeconds + "秒</span>";
      } else {
        stage1Hint.innerHTML = "10秒後に自動的に次の段階に進みます<br><span class='countdown-text'>まもなく次の段階へ進みます</span>";
      }
    }
    uiCtx.restore();
    
    // 检查是否到达10秒
    if(remaining <= 0){
      // 不在这里停止introBGM，让它继续播放到stage1.5结束
      
      // 获取原始点数据
      let rawPoints = null;
      if(lastSecondPolygon){
        rawPoints = lastSecondPolygon.map(p=>({...p}));
      } else if(latestValidPolygon) {
        rawPoints = latestValidPolygon.map(p=>({...p}));
      }
      
      // 执行自动修复：居中并调整大小
      if(rawPoints) {
        savedPolygonGlobal = normalizeConstellation(rawPoints);
      }
      
      // 即使没有形状也强制进入下一阶段，防止卡住
      stage1StartTime = 0; // 重置计时器
      
      // 停止Stage1倒计时BGM
      const stage1CountdownBGM = document.getElementById("stage1CountdownBGM");
      if (stage1CountdownBGM) {
        stage1CountdownBGM.pause();
        stage1CountdownBGM.currentTime = 0;
      }
      
      lastSecondPolygon = null;
      document.getElementById("goStage3Btn").style.display="none";
      // 隐藏提示（渐变消失）
      if(stage1Hint) {
        stage1Hint.classList.remove("visible");
        setTimeout(() => {
          stage1Hint.style.display = "none";
        }, 600);
      }
      // 阶段结束时，清理聚集动画资源
      disposeParticleCallResources();
      // 设置过渡状态，防止重复执行
      if(stage !== "stage1To1_5"){
        stage = "stage1To1_5";
        // 显示全屏标语，然后进入 stage1.5
        showStage1To1_5Tip();
      }
      return;
    }
    return;
  }

  updateActivityTime();

  let A=handsData[0], B=handsData[1];
  let left  = A[0].x < B[0].x ? A : B;
  let right = (left===A)? B : A;

  const ids=[4,8,12,20];
  let pts=[];
  for(let i of ids) pts.push(getScreenCoordinates(left[i]));
  for(let i of ids) pts.push(getScreenCoordinates(right[i]));

  // 实时连线绘制到 UI 层
  drawStage1Polyline(pts, uiCtx);

  // 保存最近一次有效的形状
  latestValidPolygon = pts.map(p=>({...p}));

  // 在最后一秒时保存星座形状
  if(remaining <= 1000 && remaining > 0){
    lastSecondPolygon = pts.map(p=>({...p}));
  }

  // 更新提示文字：显示倒计时
    if(stage1Hint) {
      if(remainingSeconds > 0) {
      stage1Hint.innerHTML = "10秒後に自動的に次の段階に進みます<br><span class='countdown-text'>残り " + remainingSeconds + "秒</span>";
      } else {
      stage1Hint.innerHTML = "10秒後に自動的に次の段階に進みます<br><span class='countdown-text'>まもなく次の段階へ進みます</span>";
    }
  }

  // 检查是否到达10秒
  if(remaining <= 0){
    // 不在这里停止introBGM，让它继续播放到stage1.5结束
    
    // 1. 获取原始点数据（优先使用 lastSecondPolygon）
    let rawPoints = null;
    if(lastSecondPolygon){
      rawPoints = lastSecondPolygon.map(p=>({...p}));
    } else if(latestValidPolygon) {
      rawPoints = latestValidPolygon.map(p=>({...p}));
    } else {
      rawPoints = pts.map(p=>({...p}));
    }
    
    // 2. 先执行标准化（缩放/移动点的位置）
    savedPolygonGlobal = normalizeConstellation(rawPoints);
    
    // 3. 【修改】基于标准化后的坐标计算并"冻结"连线结构，确保与3D显示一致
    savedConstellationEdges = computeConstellationEdges(savedPolygonGlobal);
    // stage1 已结束，保存星座形状并显示全屏标语
    stage1StartTime = 0; // 重置计时器
    
    // 停止Stage1倒计时BGM
    const stage1CountdownBGM = document.getElementById("stage1CountdownBGM");
    if (stage1CountdownBGM) {
      stage1CountdownBGM.pause();
      stage1CountdownBGM.currentTime = 0;
    }
    
    lastSecondPolygon = null;
    document.getElementById("goStage3Btn").style.display="none";
    // 隐藏 stage1 提示
    if(stage1Hint) {
      stage1Hint.classList.remove("visible");
      setTimeout(() => {
        stage1Hint.style.display = "none";
      }, 600);
    }
    // 阶段结束时，清理聚集动画资源
    disposeParticleCallResources();
    // stage1 已结束，设置一个过渡状态，保留背景但不再执行 stage1 逻辑
    if(stage !== "stage1To1_5"){
      stage = "stage1To1_5"; // 临时状态，用于显示标语
      // 显示全屏标语
      showStage1To1_5Tip();
    }
  }

  prevPts = pts.map(p=>({...p}));
  uiCtx.restore();
}
//   Stage1.5：绘画教学（完全由动作驱动的状态机）
function doStage1_5(){
  // UI 层：每一帧清除并重绘交互元素
  uiCtx.clearRect(0,0,W,H);
  
  // 艺术层：只在脏标记为 true 时更新（减少不必要的重绘）
  if(artCanvasDirty){
    artCtx.clearRect(0,0,W,H);
    // 显示星座背景（静态，绘制到艺术层）
    if(savedPolygonGlobal) {
      drawStage1Polyline(savedPolygonGlobal, artCtx, savedConstellationEdges);
    }
    // 显示已完成的绘画内容
    artCtx.drawImage(inkCanvas,0,0);
    artCanvasDirty = false; // 清除脏标记
  }

  // 显示实时视频背景（和 stage1 一样）
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.add("stage1Visible");
  }

  const now = performance.now();
  const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  
  // 【修改点】通用绘制检测：仅在非进度条阶段启用
  // 防止在按进度条时误触画笔
  if (stage1_5State !== "progressBar") {
    // 【移植 Stage 2 的手势检测逻辑】使用与 Stage 2 完全一致的检测算法
    if(handsData.length === 0) {
    // 手消失时重置状态
    stage1_5LastPos = null;
    stage1_5LastTime = null;
    // 继续执行状态机逻辑，不返回
  } else {
    let h = handsData[0];
    if(!h || !h[8] || !h[4]) {
      // 手指数据不完整时重置状态
      stage1_5LastPos = null;
      stage1_5LastTime = null;
      // 继续执行状态机逻辑，不返回
    } else {
      updateActivityTime();

      let x = mirrorX(h[8].x*W);
      let y = h[8].y*H;
      let tx = mirrorX(h[4].x*W);
      let ty = h[4].y*H;

      let d = Math.hypot(x-tx, y-ty);
      let pos = {x, y};

      // 速度检测和位置瞬移检测（与 Stage 2 完全一致）
      let isValidMovement = true;
      if(stage1_5LastPos && stage1_5LastTime){
        const timeDelta = (now - stage1_5LastTime) / 1000; // 转换为秒
        const distDelta = Math.hypot(pos.x - stage1_5LastPos.x, pos.y - stage1_5LastPos.y);
        
        if(timeDelta > 0){
          const speed = distDelta / timeDelta; // 像素/秒
          
          // 检测速度过快
          if(speed > STAGE1_5_MAX_SPEED){
            isValidMovement = false;
          }
          
          // 检测位置瞬移
          if(distDelta > STAGE1_5_MAX_JUMP_DIST){
            isValidMovement = false;
          }
        }
      }

      // 更新上一帧的位置和时间
      stage1_5LastPos = {x: pos.x, y: pos.y};
      stage1_5LastTime = now;

      if(!pinching && d < PINCH_ON){
        // 检测到捏住手势，但需要验证移动是否有效
        if(!isValidMovement){
          // 移动异常，不识别为画笔操作，只显示被动指针
          drawToolPointer(pos, {tool: "pen", passive: true});
          // 不更新状态，继续执行状态机逻辑
        } else {
          // 移动有效，开始绘制
          // 注意：Stage 1.5 没有工具栏，所以不需要 trySelectTool
          pinching = true;
          penHist = [];
          lastPen = null;
          updateActivityTime(); // 捏合开始时更新活动时间
          currentStrokePath = [];
        }
      } else if(pinching && d > PINCH_OFF){
        // 用户放开了：将完成的线条绘制到 inkCanvas 并更新艺术层
        if(currentStrokePath && currentStrokePath.length >= 2){
          // 绘制到 inkCanvas（永久存储）
          inkCtx.strokeStyle = "#ffffff";
          inkCtx.lineWidth = PEN_LINE_WIDTH;
          inkCtx.lineCap = "round";
          inkCtx.beginPath();
          inkCtx.moveTo(currentStrokePath[0].x, currentStrokePath[0].y);
          for(let i = 1; i < currentStrokePath.length; i++){
            inkCtx.lineTo(currentStrokePath[i].x, currentStrokePath[i].y);
          }
          inkCtx.stroke();
          
          // 更新艺术层：重新绘制 inkCanvas 内容
          artCtx.clearRect(0,0,W,H);
          if(savedPolygonGlobal) {
            drawStage1Polyline(savedPolygonGlobal, artCtx, savedConstellationEdges);
          }
          artCtx.drawImage(inkCanvas,0,0);
          
          strokePolylines.push(currentStrokePath);
          artCanvasDirty = true;
        }
        currentStrokePath = null;
        pinching = false;
        penHist = [];
        lastPen = null;
        updateActivityTime(); // 捏合结束时更新活动时间
        // 继续执行状态机逻辑，不返回
      }

      if(!pinching){
        // 没有捏合，显示被动指针
        drawToolPointer(pos, {tool: "pen", passive: true});
        // 继续执行状态机逻辑，不返回
      } else {
        // 在绘制过程中也检测移动异常
        if(!isValidMovement){
          // 移动异常，停止绘制
          if(currentStrokePath && currentStrokePath.length >= 2){
            strokePolylines.push(currentStrokePath);
          }
          currentStrokePath = null;
          pinching = false;
          penHist = [];
          lastPen = null;
          // 显示被动指针
          drawToolPointer(pos, {tool: "pen", passive: true});
          // 继续执行状态机逻辑，不返回
        } else {
          // 移动正常，继续绘制
          penHist.push(pos);
          if(penHist.length > MAX_HISTORY) penHist.shift();

          let p = smooth();
          if(p){
            if(!currentStrokePath) currentStrokePath = [];
            if(!lastPen){
              currentStrokePath.push({x:p.x, y:p.y});
              lastPen = {x:p.x, y:p.y};
            } else if(Math.hypot(p.x-lastPen.x, p.y-lastPen.y) > 2){
              // 正在绘制的线条：先绘制到 UI 层（实时反馈）
              // 完成后再绘制到 inkCanvas（永久存储）
              currentStrokePath.push({x:p.x, y:p.y});
              lastPen = {x:p.x, y:p.y};
            }
          }

          drawToolPointer(p || pos, {tool: "pen", passive: false});
          
          // 在 UI 层绘制正在绘制的线条（实时反馈）
          if(currentStrokePath && currentStrokePath.length >= 2){
            drawCurrentStrokePath(currentStrokePath, uiCtx);
          }
        }
      }
    }
  }
  } // 结束通用绘制检测的条件判断（仅在非进度条阶段启用）
  
  // 状态 A: "waitingPinch" (初始状态)
  if(stage1_5State === "waitingPinch"){
    // 如果用户开始绘制（在通用检测中已处理），更新状态
    if(pinching) {
      // 1. 动画立即消失（移除 visible 类，触发 CSS 淡出）
      stopPenAnimation();
      
      // 2. 状态切换
      stage1_5State = "drawing";
      stage1_5StateChangeTime = now;
      
      // 3. 检测到捏合后1秒切换标语
      setTimeout(() => {
        if(stage1_5State === "drawing") {
          enterStage1_5State("drawing");
        }
      }, 1000);
      
      // 显示绘画控制小标语（stage1.5专用）
      const drawingControlHint = document.getElementById("drawingControlHint");
      if(drawingControlHint) {
        drawingControlHint.textContent = "親指と人差し指くっつけると→ 線が出る/筆と消しゴムの切り替え　親指と人差し指離すと → 線が止まる";
        drawingControlHint.style.display = "block";
        requestAnimationFrame(() => {
          drawingControlHint.classList.add("visible");
        });
      }
    }
  }
  // 状态 B: "drawing" (绘画中) - 绘制逻辑已在通用检测中处理
  else if(stage1_5State === "drawing"){
    // 绘制逻辑已在通用检测中处理，这里只处理状态切换
    // ① drawing状态必须停至少1秒（确保用户看到标语）
    const elapsed = now - stage1_5StateChangeTime;
    if(elapsed < 1000) {
      // 如果用户松手，回到 waitingPinch
      if(!pinching){
        stage1_5State = "waitingPinch";
        // 进入新状态时切换标语（只调用一次）
        enterStage1_5State("waitingPinch");
      }
      return; // 未满1秒，不进行状态切换
    }
    
    // ② 用户"真实移动指尖"后才进入 waitingRelease
    // 添加最小位移判断：移动超过10像素才算真正开始画
    if(pinching && currentStrokePath && currentStrokePath.length >= 2){
      const first = currentStrokePath[0];
      const last = currentStrokePath[currentStrokePath.length - 1];
      const dx = last.x - first.x;
      const dy = last.y - first.y;
      const moveDist = Math.hypot(dx, dy);
      
      if(moveDist > 10) {  // 移动超过10像素才算真正开始画
        stage1_5State = "waitingRelease";
        stage1_5StateChangeTime = now;
        // 检测到用户画出来线3秒后切换标语
        setTimeout(() => {
          if(stage1_5State === "waitingRelease") {
            enterStage1_5State("waitingRelease");
          }
        }, 3000);
      }
    }
    // 如果用户松手，回到 waitingPinch
    else if(!pinching){
      stage1_5State = "waitingPinch";
      // 进入新状态时切换标语（只调用一次）
      enterStage1_5State("waitingPinch");
    }
  }
  // 状态 C: "waitingRelease" (等待松开) - 绘制逻辑已在通用检测中处理
  else if(stage1_5State === "waitingRelease"){
    // 绘制逻辑已在通用检测中处理，这里只处理状态切换
    // 如果用户松手，进入 complete
    if(!pinching){
    stage1_5State = "complete";
    stage1_5StateChangeTime = now;

    // ⭐ 延迟 300ms 再显示「描けました！！」
    setTimeout(() => {
        // 必须确认还停留在 complete
        if(stage1_5State === "complete"){
            enterStage1_5State("complete");
        }
    }, 300);
}
  }
  // 状态 D: "complete" (完成)
  else if(stage1_5State === "complete"){
    
    // ① 进入complete后必须强制停留2秒
    // 在这2秒内不要切换到progressBar状态，确保用户看到"描けました！"标语
    const elapsed = now - stage1_5StateChangeTime;
    
    // ② 2秒后进入progressBar阶段（progressBar状态会用showTipTop显示标语）
    if(elapsed >= 2000){
      // 进入进度条阶段
      stage1_5State = "progressBar";
      stage1_5StateChangeTime = now;
      stage1_5ProgressBarHolding = false;
      stage1_5ProgressBarHoldStart = 0;
      
      // 隐藏标语
      if(tip) {
        tip.classList.remove("visible");
        setTimeout(() => {
          tip.style.display = "none";
        }, TIP_FADE_DURATION);
      }
      
      // 隐藏绘画控制小标语
      const drawingControlHint = document.getElementById("drawingControlHint");
      if(drawingControlHint) {
        drawingControlHint.classList.remove("visible");
        setTimeout(() => {
          drawingControlHint.style.display = "none";
        }, 600);
      }
      
      // 延迟 800ms 后进入进度条阶段
      setTimeout(() => {
        // 进入新状态（但不更新标语，我们会用 showTipTop 单独处理）
        // 注意：enterStage1_5State 可能会触发标语更新，所以我们在后面会覆盖它
        stage1_5State = "progressBar";
        stage1_5StateChangeTime = performance.now();
        
        // 确保进度条 UI 显示
        const progressBar = document.getElementById("stage1_5ProgressBar");
        if(progressBar) {
          progressBar.style.display = "block";
          progressBar.classList.add("visible");
          // 初始化进度条 UI
          const line = document.getElementById("p09-line");
          if(line) line.style.width = "0%";
          const dots = document.querySelectorAll(".p09-dot");
          dots.forEach(d => d.classList.remove("active"));
          const targetZone = document.getElementById("p09-target");
          if(targetZone) targetZone.classList.remove("active");
        }
        
        // 显示标语（在画面上方），稍作延迟确保覆盖其他可能的标语更新
        setTimeout(() => {
          showTipTop("下のボタンを長押しして、次のステージに入りましょう！");
        }, 100);
      }, 800);
    }
  }
  // 状态 E: "progressBar" (进度条阶段)
  else if(stage1_5State === "progressBar"){
    // 标语已在状态切换时通过 enterStage1_5State("progressBar") 设置
    
    // 【1】检测捏合手势 - 获取手势数据
    if(handsData.length === 0) {
      // 没有检测到手，重置状态
      if(stage1_5ProgressBarHolding) {
        stage1_5ProgressBarHolding = false;
        stage1_5ProgressBarHoldStart = 0;
      }
      return;
    }
    
    let h = handsData[0];
    if(!h || !h[8] || !h[4]) {
      // 手势数据不完整，重置状态
      if(stage1_5ProgressBarHolding) {
        stage1_5ProgressBarHolding = false;
        stage1_5ProgressBarHoldStart = 0;
      }
      return;
    }
    
    updateActivityTime();
    
    // 进度条阶段：检测手势是否在进度条中间位置并捏住
    const progressBar = document.getElementById("stage1_5ProgressBar");
    
    if(!progressBar) return;
    
    // 确保进度条已显示
    if(!progressBar.classList.contains("visible")) {
      progressBar.classList.add("visible");
    }
    
    // 【2】检测手的位置是否在进度条 hitbox 内
    // 获取进度条的位置和大小（屏幕坐标）
    const barRect = progressBar.getBoundingClientRect();
    if(barRect.width === 0 || barRect.height === 0) {
      // 进度条还没有渲染，等待下一帧
      return;
    }
    
    // 手势坐标（画布坐标系统）
    const p8 = getScreenCoordinates(h[8]);
    const p4 = getScreenCoordinates(h[4]);
    let handX = p8.x;
    let handY = p8.y;
    let thumbX = p4.x;
    let thumbY = p4.y;
    
    // 计算手指中心位置（画布坐标）
    const fingerCenterX = (handX + thumbX) / 2;
    const fingerCenterY = (handY + thumbY) / 2;
    
    // 计算食指和拇指之间的距离（用于检测是否捏住）
    const pinchDist = Math.hypot(handX - thumbX, handY - thumbY);
    
    // 进度条中心位置（屏幕坐标）
    const barCenterXScreen = barRect.left + barRect.width / 2;
    const barCenterYScreen = barRect.top + barRect.height / 2;
    
    // 将屏幕坐标转换为画布坐标
    // 假设画布和屏幕大小一致（W和H是画布尺寸）
    const barCenterX = barCenterXScreen;
    const barCenterY = barCenterYScreen;
    
    // 【修改 1】极大幅度放宽判定范围
    // 直接给一个固定的超大半径 (例如 250px，相当于 500x500 的区域)
    // 只要手在屏幕中央附近，就算对准了
    const tolerance = 250; 
    
    const isInBarArea = Math.abs(fingerCenterX - barCenterX) < tolerance &&
                        Math.abs(fingerCenterY - barCenterY) < tolerance;
    
    // 【修改 2】确保捏合阈值足够宽松 (3.0倍)
    const isPinching = pinchDist < PINCH_ON * 3.0;
    
    // 更新 pinching 状态（用于视觉反馈）
    pinching = isPinching;
    
    // 判断当前是否满足条件
    const isValidNow = isInBarArea && isPinching;
    
    // 【3】开始计时推进进度条（只有持续捏合才会进展）
    if(isValidNow){
      // 在进度条中间且捏住
      if(!stage1_5ProgressBarHolding){
        // 开始按住
        stage1_5ProgressBarHolding = true;
        stage1_5ProgressBarHoldStart = now;
      }
      
      // 计算进度（使用 clamp 确保在 0-1 之间）
      const holdElapsed = now - stage1_5ProgressBarHoldStart;
      const progress = Math.min(1, Math.max(0, holdElapsed / STAGE1_5_PROGRESS_DURATION));
      const progressPercent = progress * 100;
      
      // 1. 更新识别圈的激活状态 (捏合反馈)
      const targetZone = document.getElementById("p09-target");
      if(targetZone){
        targetZone.classList.add("active"); // 捏合：微缩微亮
      }
      
      // 2. 更新进度条宽度
      const line = document.getElementById("p09-line");
      if(line) {
        line.style.width = progressPercent + "%";
      }
      
      // 3. 更新星星节点的点亮状态
      const d1 = document.getElementById("p09-d1");
      const d2 = document.getElementById("p09-d2");
      const d3 = document.getElementById("p09-d3");
      const d4 = document.getElementById("p09-d4");
      if(d1) { if(progressPercent > 0) d1.classList.add("active"); else d1.classList.remove("active"); }
      if(d2) { if(progressPercent > 33) d2.classList.add("active"); else d2.classList.remove("active"); }
      if(d3) { if(progressPercent > 66) d3.classList.add("active"); else d3.classList.remove("active"); }
      if(d4) { if(progressPercent >= 99) d4.classList.add("active"); else d4.classList.remove("active"); }
      
      // 【5】完成后进入下一阶段
      if(progress >= 1){
        // 隐藏进度条标语（使用 tipOverlay）
        const tip = document.getElementById("tipOverlay");
        if(tip) {
          tip.classList.remove("visible");
          setTimeout(() => {
            tip.style.display = "none";
          }, TIP_FADE_DURATION);
        }
        if(progressBar) {
          progressBar.classList.remove("visible");
          setTimeout(() => {
            progressBar.style.display = "none";
          }, 600);
        }
        // 重置状态
        stage1_5ProgressBarHolding = false;
        stage1_5ProgressBarHoldStart = 0;
        // 重置 stage1 手势识别状态，防止重复触发
        stage1TipSequenceState = "completed";
        stage1GestureDetectionStartTime = 0;
        // 显示过渡标语
        showStage1_5To2Tip();
      }
    } else {
      // 【4】离开范围或松开时立即重置
      // 更新识别圈状态（松开状态）
      const targetZone = document.getElementById("p09-target");
      if(targetZone) {
        targetZone.classList.remove("active"); // 松开：恢复呼吸
      }
      
      // 立即重置进度（不再使用宽限期）
      if(stage1_5ProgressBarHolding){
        stage1_5ProgressBarHolding = false;
        stage1_5ProgressBarHoldStart = 0;
        stage1_5ProgressBarLastValidTime = 0;
        // 重置进度条 UI
        const line = document.getElementById("p09-line");
        if(line) line.style.width = "0%";
        const dots = document.querySelectorAll(".p09-dot");
        dots.forEach(d => d.classList.remove("active"));
      }
    }
  }
  
  // 在 UI 层绘制正在绘制的线条（实时反馈）
  if(currentStrokePath && currentStrokePath.length >= 2){
    drawCurrentStrokePath(currentStrokePath, uiCtx);
  }
}

// Stage2：绘画
let inkCanvas=document.createElement("canvas");
inkCanvas.width=W; inkCanvas.height=H;
let inkCtx=inkCanvas.getContext("2d");

let penHist=[];
let lastPen=null;
let pinching=false;

const MAX_HISTORY=5;
const PINCH_ON=35;
const PINCH_OFF=65;

// 生成圆形进度条的 clip-path 点
function generateCircleClipPath(angleDeg) {
  // 角度转换为弧度，从-90度开始（顶部）
  const startAngle = -90;
  const angleRad = (angleDeg * Math.PI) / 180;
  const startRad = (startAngle * Math.PI) / 180;
  
  // 计算扇形的点
  const points = [];
  const centerX = 50; // 百分比
  const centerY = 50; // 百分比
  const radius = 50; // 百分比
  
  // 起始点：顶部中心
  points.push(`${centerX}% ${centerY - radius}%`);
  
  // 如果角度大于0，添加扇形的弧线点
  if (angleDeg > 0) {
    // 计算结束角度
    const endRad = startRad + angleRad;
    
    // 根据角度分段，每15度一个点
    const segments = Math.ceil(angleDeg / 15);
    for (let i = 1; i <= segments; i++) {
      const segmentAngle = (angleDeg * i) / segments;
      const segmentRad = startRad + (segmentAngle * Math.PI) / 180;
      const x = centerX + radius * Math.cos(segmentRad);
      const y = centerY + radius * Math.sin(segmentRad);
      points.push(`${x}% ${y}%`);
    }
  }
  
  // 结束点：中心点
  points.push(`${centerX}% ${centerY}%`);
  
  return points.join(', ');
}

const PEN_LINE_WIDTH = 3;
const ERASER_LINE_WIDTH = PEN_LINE_WIDTH * 10;

let strokePolylines=[];
let currentStrokePath=null;
// 艺术层脏标记：当 inkCanvas 内容变化时设置为 true，需要更新艺术层
let artCanvasDirty = false;

const toolOverlay = document.getElementById("toolOverlay");
const toolButtons = {
  pen: toolOverlay ? toolOverlay.querySelector('[data-tool="pen"]') : null,
  eraser: toolOverlay ? toolOverlay.querySelector('[data-tool="eraser"]') : null,
  undo: toolOverlay ? toolOverlay.querySelector('[data-tool="undo"]') : null
};
let currentTool="pen";
const TOOL_LOCK_DURATION = 2000;
let toolLockUntil = 0;

function setToolLockNow(){
  toolLockUntil = performance.now() + TOOL_LOCK_DURATION;
}
function setToolOverlayVisible(show){
  if(!toolOverlay) return;
  toolOverlay.style.display = show ? "flex" : "none";
}
function highlightTool(tool){
  currentTool = tool;
  for(let key in toolButtons){
    if(!toolButtons[key]) continue;
    toolButtons[key].classList.toggle("active", key === tool);
  }
  updateActivityTime(); // 换工具时更新活动时间
}
highlightTool("pen");

function getToolHit(pos){
  if(!toolOverlay || stage !== 2) return null;
  const entries = Object.entries(toolButtons);
  for(let [tool, el] of entries){
    if(!el) continue;
    const rect = el.getBoundingClientRect();
    if(pos.x >= rect.left && pos.x <= rect.right && pos.y >= rect.top  && pos.y <= rect.bottom){
      return tool;
    }
  }
  return null;
}

function cloneStrokePolylines(){
  return strokePolylines.map(path=>path.map(p=>({...p})));
}

function normalizeStrokePolylines(raw){
  if(!raw) return [];
  if(Array.isArray(raw) && raw.length>0 && Array.isArray(raw[0])){
    return raw.map(path => path.map(pt=>({...pt})));
  }
  if(Array.isArray(raw)){
    return raw.length ? [raw.map(pt=>({...pt}))] : [];
  }
  return [];
}

function smooth(){
  if(penHist.length===0) return null;
  let sx=0, sy=0, wsum=0;
  for(let i=0;i<penHist.length;i++){
    let w=i+1;
    sx += penHist[i].x * w;
    sy += penHist[i].y * w;
    wsum+=w;
  }
  return {x:sx/wsum, y:sy/wsum};
}

// 在 UI 层绘制正在绘制的线条（实时反馈）
function drawCurrentStrokePath(path, ctx = uiCtx){
  if(!path || path.length < 2) return;
  ctx.save();
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = PEN_LINE_WIDTH;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for(let i = 1; i < path.length; i++){
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawToolPointer(p, options={}){
  const tool = options.tool || currentTool;
  const passive = !!options.passive;
  if(!tool) return;
  const isPen = tool === "pen";
  uiCtx.save();
  uiCtx.beginPath();
  const radius = isPen ? 11 : 16;
  if(passive){
    uiCtx.strokeStyle = isPen ? "rgba(255,255,255,0.5)" : "rgba(255,200,120,0.5)";
    uiCtx.fillStyle = isPen ? "rgba(255,255,255,0.08)" : "rgba(255,200,120,0.12)";
    uiCtx.setLineDash([4,4]);
  }else{
    uiCtx.strokeStyle = isPen ? "rgba(255,255,255,0.9)" : "rgba(255,200,120,0.95)";
    uiCtx.fillStyle = isPen ? "rgba(255,255,255,0.15)" : "rgba(255,200,120,0.18)";
  }
  uiCtx.lineWidth = 2;
  uiCtx.arc(p.x, p.y, radius, 0, Math.PI*2);
  uiCtx.fill();
  uiCtx.stroke();
  uiCtx.restore();
}

function drawEraserDashedBox(p, options={}){
  const passive = !!options.passive;
  uiCtx.save();
  uiCtx.lineWidth = 2;
  uiCtx.setLineDash([6,4]);
  uiCtx.strokeStyle = passive ? "rgba(255,200,120,0.45)" : "rgba(255,200,120,0.95)";
  uiCtx.fillStyle = passive ? "rgba(255,200,120,0.06)" : "rgba(255,200,120,0.10)";
  const w = 40;
  const h = 60;
  uiCtx.beginPath();
  uiCtx.rect(p.x - w/2, p.y - h/2, w, h);
  uiCtx.fill();
  uiCtx.stroke();
  uiCtx.restore();
}

// 手势悬停检测函数：根据指尖位置高亮按钮
function updateToolHoverVisuals(pos) {
  // 只在 Stage 2 且工具栏显示时运行
  const overlay = document.getElementById("toolOverlay");
  if (!overlay || overlay.style.display === "none") return;
  const buttons = document.querySelectorAll('.toolBuoy');
  
  buttons.forEach(btn => {
    const rect = btn.getBoundingClientRect();
    
    // 稍微扩大一点识别范围 (+10px)，让手感更宽松
    const padding = 10;
    const isHovering = 
      pos.x >= rect.left - padding && 
      pos.x <= rect.right + padding && 
      pos.y >= rect.top - padding && 
      pos.y <= rect.bottom + padding;
    if (isHovering) {
      btn.classList.add('hand-hover');
    } else {
      btn.classList.remove('hand-hover');
    }
  });
}

function eraseStrokeDataAtPoint(px, py, radius){
  if(strokePolylines.length===0) return;
  const updated=[];
  for(let path of strokePolylines){
    let seg=[];
    for(let pt of path){
      const dist = Math.hypot(pt.x - px, pt.y - py);
      if(dist <= radius){
        if(seg.length >= 2) updated.push(seg);
        seg=[];
      }else{
        seg.push({...pt});
      }
    }
    if(seg.length >= 2) updated.push(seg);
  }
  strokePolylines = updated;
}

function eraseStrokeDataBetween(a, b){
  const radius = ERASER_LINE_WIDTH * 0.5;
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.hypot(dx, dy);
  const steps = Math.max(1, Math.ceil(dist / Math.max(1, radius * 0.6)));
  for(let i=0;i<=steps;i++){
    const t = steps === 0 ? 0 : i / steps;
    const px = a.x + dx * t;
    const py = a.y + dy * t;
    eraseStrokeDataAtPoint(px, py, radius);
  }
}

let lastUndoTime = 0;
// --- 重新绘制所有线条的辅助函数 (保持不变) ---
function redrawInkCanvas() {
  inkCtx.clearRect(0, 0, W, H);
  inkCtx.strokeStyle = "#ffffff";
  inkCtx.lineWidth = PEN_LINE_WIDTH;
  inkCtx.lineCap = "round";

  for (let path of strokePolylines) {
    if (path.length < 2) continue;
    inkCtx.beginPath();
    inkCtx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
      inkCtx.lineTo(path[i].x, path[i].y);
    }
    inkCtx.stroke();
  }
  artCanvasDirty = true;
}

// --- 修改后的工具选择逻辑 (加入了防抖动冷却) ---
function trySelectTool(pos){
  const hit = getToolHit(pos);
  if(!hit) return false;
  
  // 如果是撤销按钮
  if(hit === "undo"){
    const now = performance.now();
    
    // 【核心修复】防抖动检测：如果距离上次撤销不到 500毫秒，
    // 虽然识别到了按钮点击，但不执行撤销动作。
    // 返回 true 是为了告诉系统 "我正在按按钮，不要在画布上画线"
    if (now - lastUndoTime < 500) {
      return true; 
    }

    // 只有超过冷却时间，才真正执行撤销
    if(strokePolylines.length > 0){
      strokePolylines.pop(); // 移除最后一笔
      redrawInkCanvas();     // 重绘
      
      // 更新最后撤销时间
      lastUndoTime = now;
      
      // 视觉反馈：闪烁一下
      if(toolButtons.undo) toolButtons.undo.classList.add("active");
      setTimeout(() => {
        if(toolButtons.undo) toolButtons.undo.classList.remove("active");
      }, 200);
    }
    
    updateActivityTime();
    return true;
  }

  // 其他工具（画笔/橡皮）逻辑保持不变
  highlightTool(hit);
  setToolLockNow();
  penHist=[];
  lastPen=null;
  currentStrokePath=null;
  updateActivityTime(); 
  return true;
}
function doStage2(){
  // 确保绘画控制小标语一直显示（stage2中一直显示）
  const drawingControlHint = document.getElementById("drawingControlHint");
  if(drawingControlHint && stage === 2) {
    // 设置stage2专用标语
    drawingControlHint.textContent = "親指と人差し指くっつけると→ 線が出る/筆と消しゴムの切り替え　親指と人差し指離すと → 線が止まる";
    if(drawingControlHint.style.display !== "block") {
      drawingControlHint.style.display = "block";
    }
    if(!drawingControlHint.classList.contains("visible")) {
      requestAnimationFrame(() => {
        drawingControlHint.classList.add("visible");
      });
    }
  }
  
  // UI 层：每一帧清除并重绘交互元素
  uiCtx.clearRect(0,0,W,H);
  
  // 艺术层：只在脏标记为 true 时更新（减少不必要的重绘）
  if(artCanvasDirty){
    artCtx.clearRect(0,0,W,H);
    // 显示星座背景（静态，绘制到艺术层）
    if(savedPolygonGlobal) {
      drawStage1Polyline(savedPolygonGlobal, artCtx, savedConstellationEdges);
    }
    // 显示已完成的绘画内容
    artCtx.drawImage(inkCanvas,0,0);
    artCanvasDirty = false; // 清除脏标记
  }

  if(handsData.length===0) {
    // 手消失时重置状态
    stage2LastPos = null;
    stage2LastTime = null;
    return;
  }

  let h=handsData[0];
  if(!h[8]||!h[4]) {
    // 手指数据不完整时重置状态
    stage2LastPos = null;
    stage2LastTime = null;
    return;
  }

  updateActivityTime();

  let x = mirrorX(h[8].x*W);
  let y = h[8].y*H;
  let tx= mirrorX(h[4].x*W);
  let ty= h[4].y*H;

  let d = Math.hypot(x-tx, y-ty);
  let pos={x,y};
  // 【新增】调用手势悬停检测
  updateToolHoverVisuals(pos);
  const now = performance.now();

  // 速度检测和位置瞬移检测
  let isValidMovement = true;
  if(stage2LastPos && stage2LastTime){
    const timeDelta = (now - stage2LastTime) / 1000; // 转换为秒
    const distDelta = Math.hypot(pos.x - stage2LastPos.x, pos.y - stage2LastPos.y);
    
    if(timeDelta > 0){
      const speed = distDelta / timeDelta; // 像素/秒
      
      // 检测速度过快
      if(speed > STAGE2_MAX_SPEED){
        isValidMovement = false;
      }
      
      // 检测位置瞬移
      if(distDelta > STAGE2_MAX_JUMP_DIST){
        isValidMovement = false;
      }
    }
  }

  // 更新上一帧的位置和时间
  stage2LastPos = {x: pos.x, y: pos.y};
  stage2LastTime = now;

  if(!pinching && d<PINCH_ON){
    // 检测到捏住手势，但需要验证移动是否有效
    if(!isValidMovement){
      // 移动异常，不识别为画笔操作，只显示被动指针
      if(currentTool === "pen"){
        drawToolPointer(pos,{tool:"pen", passive:true});
      }else if(currentTool === "eraser"){
        drawEraserDashedBox(pos,{passive:true});
      }
      return;
    }
    
    if(trySelectTool(pos)){
      return;
    }
    pinching=true;
    penHist=[];
    lastPen=null;
    updateActivityTime(); // 捏合开始时更新活动时间

    if(currentTool === "pen"){
      if(performance.now() < toolLockUntil){
        currentStrokePath = null;
      }else{
        currentStrokePath = [];
      }
    }else{
      currentStrokePath=null;
    }
  }else if(pinching && d>PINCH_OFF){
    // 用户放开了：将完成的线条绘制到 inkCanvas 并更新艺术层
    if(currentTool === "pen" && currentStrokePath && currentStrokePath.length>=2){
      // 绘制到 inkCanvas（永久存储）
      inkCtx.strokeStyle="#ffffff";
      inkCtx.lineWidth=PEN_LINE_WIDTH;
      inkCtx.lineCap="round";
      inkCtx.beginPath();
      inkCtx.moveTo(currentStrokePath[0].x, currentStrokePath[0].y);
      for(let i = 1; i < currentStrokePath.length; i++){
        inkCtx.lineTo(currentStrokePath[i].x, currentStrokePath[i].y);
      }
      inkCtx.stroke();
      
      // 更新艺术层：重新绘制 inkCanvas 内容
      artCtx.clearRect(0,0,W,H);
      if(savedPolygonGlobal) {
        drawStage1Polyline(savedPolygonGlobal, artCtx, savedConstellationEdges);
      }
      artCtx.drawImage(inkCanvas,0,0);
      
      strokePolylines.push(currentStrokePath);
    }
    currentStrokePath=null;
    pinching=false;
    penHist=[]; lastPen=null;
    updateActivityTime(); // 捏合结束时更新活动时间
    return;
  }

  if(!pinching){
    if(currentTool === "pen"){
      drawToolPointer(pos,{tool:"pen", passive:true});
    }else if(currentTool === "eraser"){
      drawEraserDashedBox(pos,{passive:true});
    }
    return;
  }

  // 在绘制过程中也检测移动异常
  if(!isValidMovement){
    // 移动异常，停止绘制
    if(currentTool === "pen" && currentStrokePath && currentStrokePath.length>=2){
      strokePolylines.push(currentStrokePath);
    }
    currentStrokePath=null;
    pinching=false;
    penHist=[];
    lastPen=null;
    // 显示被动指针
    if(currentTool === "pen"){
      drawToolPointer(pos,{tool:"pen", passive:true});
    }else if(currentTool === "eraser"){
      drawEraserDashedBox(pos,{passive:true});
    }
    return;
  }

  penHist.push(pos);
  if(penHist.length>MAX_HISTORY) penHist.shift();

  let p=smooth();
  if(!p) return;

  if(currentTool === "pen"){
    const now = performance.now();
    if(now < toolLockUntil){
      lastPen = {x:p.x, y:p.y};
      drawToolPointer(p, {tool:"pen", passive:false});
      return;
    }

    if(!currentStrokePath) currentStrokePath=[];
    if(!lastPen){
      currentStrokePath.push({x:p.x,y:p.y});
      lastPen={x:p.x,y:p.y};
    }else if(Math.hypot(p.x-lastPen.x,p.y-lastPen.y)>2){
      // 正在绘制的线条：先绘制到 UI 层（实时反馈）
      // 完成后再绘制到 inkCanvas（永久存储）
      currentStrokePath.push({x:p.x,y:p.y});
      lastPen={x:p.x,y:p.y};
    }
  }else{
    if(!lastPen) lastPen={x:p.x,y:p.y};
    inkCtx.save();
    inkCtx.globalCompositeOperation="destination-out";
    inkCtx.strokeStyle="rgba(0,0,0,1)";
    inkCtx.lineWidth=ERASER_LINE_WIDTH;
    inkCtx.lineCap="round";
    inkCtx.beginPath();
    inkCtx.moveTo(lastPen.x,lastPen.y);
    inkCtx.lineTo(p.x,p.y);
    inkCtx.stroke();
    inkCtx.restore();
    eraseStrokeDataBetween(lastPen, {x:p.x,y:p.y});
    lastPen={x:p.x,y:p.y};
    // 橡皮擦操作后设置脏标记
    artCanvasDirty = true;
  }

  if(currentTool === "pen"){
    drawToolPointer(p,{tool:"pen", passive:false});
  }else if(currentTool === "eraser"){
    drawEraserDashedBox(p,{passive:false});
  }
  
  // 在 UI 层绘制正在绘制的线条（实时反馈）
  if(currentTool === "pen" && currentStrokePath && currentStrokePath.length >= 2){
    drawCurrentStrokePath(currentStrokePath, uiCtx);
  }
}

function resetStage2PushDetection(){
  stage2HandInitialDist = null;
  stage2PushFrames = 0;
}

function startStage2Warp(){
  if(stage2Warping || stage !== 2) return;
  stage2Warping = true;
  stage2WarpStart = performance.now();
  stage2WarpStartZ = camera.position.z;
  // 【核心修复】改为 -1000
  // 保证相机(终点-1000)永远在星座(终点-1800)的后面
  // 这样用户才能全程看着星座飞向深空，而不是飞过头把它甩在身后
  stage2WarpTargetZ = -1000; 
  document.getElementById("goStage3Btn").style.display = "none";

  // 确保已经有 3D 影子星座
  if(!shadowConstellation){
    prepareShadowConstellationForStage2();
  }
  
  // 1. 【恢复旧版】先显示 3D 星座，设置初始位置为 startZ (baseZ + 3000)
  if(shadowConstellation){
    shadowConstellation.visible = true;
    const baseZ = (shadowConstellation.userData && shadowConstellation.userData.baseZ !== undefined)
      ? shadowConstellation.userData.baseZ
      : -1800;
    const startZ = baseZ + 3000; // 旧版效果：从极远处开始
    shadowConstellation.position.z = startZ;
    shadowConstellation.scale.set(1, 1, 1);
  }

  // 2. 【恢复旧版】2D 画布溶解动画（不立即隐藏）
  // 保持 artCanvas 显示，进行溶解动画
  if(artCanvas) {
    artCanvas.style.display = "block";
    artCanvas.style.transition = "none";
    artCanvas.style.transform = "scale(1)";
    artCanvas.style.filter = "blur(0vmin)";
    artCanvas.style.opacity = "1";
    
    // 强制重排
    void artCanvas.offsetWidth;
    
    // 开始溶解动画：缩小、模糊、透明
    artCanvas.style.transition = "transform 400ms cubic-bezier(0.4, 0, 0.2, 1), filter 400ms ease-out, opacity 400ms ease-out";
    artCanvas.style.transform = "scale(0.1)";
    artCanvas.style.filter = "blur(2.5vmin)";
    artCanvas.style.opacity = "0";
    
    // 动画结束后隐藏
    setTimeout(() => {
      artCanvas.style.display = "none";
      uiCanvas.style.display = "none";
    }, 400);
  } else {
    // 如果 artCanvas 不存在，延迟隐藏
    setTimeout(() => {
      if(uiCanvas) uiCanvas.style.display = "none";
    }, 100);
  }
}

function finalizeStage2ToStage3(){
  stage2Warping = false;
  enterStage3FromStage2();
}

function detectStage2HandsAndMaybeWarp(){
  // 0. 基础状态检查
  if(stage !== 2 || stage2Warping) return;
  const now = performance.now();
  
  // 必须检测到两只手
  if(!handsData || handsData.length < 2) {
    stage2PushInitialDist = null;
    return;
  }

  let hand1 = handsData[0];
  let hand2 = handsData[1];
  if(!hand1[8] || !hand1[4] || !hand2[8] || !hand2[4]) return;

  // 1. 坐标计算 (用于防误触检测)
  // 手 1
  let p1_8 = getScreenCoordinates(hand1[8]);
  let p1_4 = getScreenCoordinates(hand1[4]);
  let h1x = p1_8.x, h1y = p1_8.y; // 食指
  let t1x = p1_4.x, t1y = p1_4.y; // 拇指
  // 手 2
  let p2_8 = getScreenCoordinates(hand2[8]);
  let p2_4 = getScreenCoordinates(hand2[4]);
  let h2x = p2_8.x, h2y = p2_8.y; // 食指
  let t2x = p2_4.x, t2y = p2_4.y; // 拇指

  // 2. 【防误触核心 A：停笔检测】
  // 检测两只手是否都在捏合。如果任意一只手捏合（距离 < PINCH_OFF），说明还在画画，强制中断。
  const pinch1 = Math.hypot(h1x - t1x, h1y - t1y);
  const pinch2 = Math.hypot(h2x - t2x, h2y - t2y);
  
  if (pinch1 < PINCH_OFF || pinch2 < PINCH_OFF) {
    stage2PushInitialDist = null; // 重置进度
    return; // 只要还在画，就绝不穿越
  }

  // 3. 【防误触核心 B：水平对齐检测】
  // 双手向前推时，两只手的高度应该差不多。如果高度差过大（>250px），视为路人干扰或无效动作。
  // 使用手腕位置(点0)来判断高度更稳定
  let w1 = getScreenCoordinates(hand1[0]);
  let w2 = getScreenCoordinates(hand2[0]);
  let w1y = w1.y;
  let w2y = w2.y;
  if (Math.abs(w1y - w2y) > 250) {
    stage2PushInitialDist = null;
    return;
  }

  // 4. 【动作核心：计算手掌大小 (模拟 Z 轴推入)】
  // 原理：当手推向屏幕时，手掌在画面中的像素面积会变大。
  // 使用 "手腕(0) 到 中指根部(9)" 的距离作为基准，这个距离比指尖更稳定，不受手指弯曲影响。
  const getSize = (h) => {
    let p0 = getScreenCoordinates(h[0]);
    let p9 = getScreenCoordinates(h[9]);
    return Math.hypot(p0.x - p9.x, p0.y - p9.y);
  };

  const size1 = getSize(hand1);
  const size2 = getSize(hand2);
  const currentTotalSize = size1 + size2; // 两手大小之和

  // 5. 推入判定逻辑
  if(stage2PushInitialDist === null){
    // 初始化基准值
    stage2PushInitialDist = currentTotalSize;
    stage2PushMinDist = currentTotalSize; 
    stage2PushDetectionStartTime = now;
  }

  // 动态更新基准：如果手缩回去了（变小了），就以新的小尺寸作为起点
  // 这样保证了必须是"从当前位置向前推"才算数
  if(currentTotalSize < stage2PushMinDist) {
    stage2PushMinDist = currentTotalSize;
    stage2PushInitialDist = currentTotalSize; 
  }

  // 计算变大程度 (推向屏幕的程度)
  const sizeIncrease = currentTotalSize - stage2PushInitialDist;
  
  // 触发阈值：手掌总大小增加 60 像素
  // 这意味着双手有明显的向前推（靠近摄像头）的动作
  const REQUIRED_SIZE_INCREASE = 60; 
  
  if(sizeIncrease >= REQUIRED_SIZE_INCREASE){
    // 触发成功！
    startStage2Warp();
    stage2PushInitialDist = null;
  } else if(now - stage2PushDetectionStartTime > 5000){
    // 超时重置，防止误积累
    stage2PushInitialDist = null; 
    stage2PushDetectionStartTime = 0;
  }
}


//   Three.js 初始化
const container = document.getElementById("threeContainer");
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, W/H, 1, 200000);
// 初始相机位置设置为标题位置
camera.position.set(0, 0, 24);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(W, H);
renderer.setClearColor(0x000000, 1);
container.appendChild(renderer.domElement);

window.addEventListener("resize", ()=>{
  W = window.innerWidth;
  H = window.innerHeight;
  artCanvas.width = W;
  artCanvas.height = H;
  uiCanvas.width = W;
  uiCanvas.height = H;
  inkCanvas.width = W;
  inkCanvas.height = H;
  renderer.setSize(W,H);
  camera.aspect = W/H;
  camera.updateProjectionMatrix();
});

//   标题界面星系背景（从背景.html移植）
let titleGalaxyParticles = null;
let titleOuterGalaxyParticles = null;
let titleNebulaBackground = null;
let titleGalacticCore = null;
let titleDeepStars = null;

// 星系粒子参数
const TITLE_GALAXY_PARAMS = {
  count: 80000,
  size: 0.2,
  radius: 12,
  branches: 3,
  spin: 1,
  randomness: 0.5,
  randomnessPower: 3,
  insideColor: '#ffce9e',
  outsideColor: '#6c8dff',
};

// 外层大星系参数（11倍大小）
const OUTER_GALAXY_PARAMS = {
  count: 80000,
  size: 0.28,
  radius: 132, // 12 * 11 = 132
  branches: 3,
  spin: 1,
  randomness: 0.5,
  randomnessPower: 3,
  insideColor: '#ffce9e',
  outsideColor: '#6c8dff',
  innerRadius: 14, // 内环半径，避免与内层星系重叠
};

// 创建深空背景星星 (Z轴纵深无限)
function createTitleDeepStars() {
  const count = 5000;
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  
  for(let i = 0; i < count; i++) {
    // 广阔分布在 X/Y 平面
    const r = 200 + Math.random() * 1800;
    const theta = Math.random() * Math.PI * 2;
    // 分布在 Z 轴 -20000 到 2000 之间 (涵盖超长穿越深度)
    const z = -20000 + Math.random() * 22000;
    
    positions[i*3] = r * Math.cos(theta);
    positions[i*3+1] = r * Math.sin(theta);
    positions[i*3+2] = z;
    
    sizes[i] = 1.0 + Math.random() * 3.0;
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.ShaderMaterial({
    uniforms: { uColor: { value: new THREE.Color(0xffffff) } },
    vertexShader: `
      attribute float size;
      void main() {
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        float dist = length(mvPosition.xyz);
        gl_PointSize = size * (1500.0 / max(dist, 1.0));
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      void main() {
        vec2 uv = gl_PointCoord - vec2(0.5);
        if(length(uv) > 0.5) discard;
        float alpha = 1.0 - smoothstep(0.1, 0.5, length(uv));
        gl_FragColor = vec4(uColor, alpha * 0.8);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  
  const points = new THREE.Points(geometry, material);
  points.visible = true; // 默认显示，在标题界面显示
  return points;
}

// 创建星系粒子系统（通用函数，支持 innerRadius）
function createGalaxyParticles(parameters) {
  const { count, radius, branches, spin, randomness, randomnessPower, insideColor, outsideColor, size, innerRadius = 0 } = parameters;
  
  // 创建星星纹理
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  const centerX = 32;
  const centerY = 32;
  const radius_grad = 28;
  const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius_grad);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.9)');
  gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);
  const starTexture = new THREE.CanvasTexture(canvas);
  starTexture.premultiplyAlpha = true;
  
  // 生成位置和颜色
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const colorInside = new THREE.Color(insideColor);
  const colorOutside = new THREE.Color(outsideColor);
  
  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    // 如果有 innerRadius，则在 innerRadius 到 radius 之间分布
    const r = innerRadius + Math.random() * (radius - innerRadius);
    const spinAngle = r * spin;
    const branchAngle = ((i % branches) / branches) * Math.PI * 2;
    const randomX = Math.pow(Math.random(), randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;
    const randomY = Math.pow(Math.random(), randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;
    const randomZ = Math.pow(Math.random(), randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;
    
    positions[i3] = Math.cos(branchAngle + spinAngle) * r + randomX;
    positions[i3 + 1] = randomY * 0.5;
    positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * r + randomZ;
    
    // 颜色插值基于相对位置（从 innerRadius 到 radius）
    const relativeR = (r - innerRadius) / (radius - innerRadius);
    const mixedColor = colorInside.clone().lerp(colorOutside, relativeR);
    colors[i3] = mixedColor.r;
    colors[i3 + 1] = mixedColor.g;
    colors[i3 + 2] = mixedColor.b;
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const material = new THREE.PointsMaterial({
    size: size,
    map: starTexture,
    sizeAttenuation: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    alphaMap: starTexture,
    alphaTest: 0.001
  });
  
  const points = new THREE.Points(geometry, material);
  const tiltRotation = 8 * (Math.PI / 180);
  points.rotation.set(tiltRotation, 0, tiltRotation);
  points.visible = true; // 默认显示，在标题界面显示
  
  return points;
}

// 创建内层星系粒子系统（保持向后兼容）
function createTitleGalaxyParticles() {
  return createGalaxyParticles(TITLE_GALAXY_PARAMS);
}

// 创建外层星系粒子系统
function createTitleOuterGalaxyParticles() {
  return createGalaxyParticles(OUTER_GALAXY_PARAMS);
}

// 创建星云背景
function createTitleNebulaBackground() {
  const nebulaVS = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;
  
  const nebulaFS = `
    uniform float uTime;
    uniform vec3 uColor1;
    uniform vec3 uColor2;
    uniform vec3 uColor3;
    varying vec2 vUv;
    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
    float noise(vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);
      float a = random(i);
      float b = random(i + vec2(1.0, 0.0));
      float c = random(i + vec2(0.0, 1.0));
      float d = random(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }
    float fbm(vec2 st) {
      float v = 0.0;
      float a = 0.5;
      mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
      for (int i = 0; i < 5; ++i) {
        v += a * noise(st);
        st = rot * st * 2.0;
        a *= 0.5;
      }
      return v;
    }
    void main() {
      vec2 st = vUv * 3.0;
      float q = fbm(st + uTime * 0.05);
      vec2 r = vec2(fbm(st + q + uTime * 0.1 + vec2(1.7, 9.2)), fbm(st + q + uTime * 0.1 + vec2(8.3, 2.8)));
      float f = fbm(st + r);
      vec3 color = mix(uColor1, uColor2, clamp(f*f*4.0, 0.0, 1.0));
      color = mix(color, uColor3, clamp(length(r), 0.0, 1.0));
      float voidMask = smoothstep(0.2, 0.8, f);
      color *= voidMask;
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const uniforms = {
    uTime: { value: 0 },
    uColor1: { value: new THREE.Color('#000000') },
    uColor2: { value: new THREE.Color('#0b1026') },
    uColor3: { value: new THREE.Color('#201130') },
  };
  
  const geometry = new THREE.SphereGeometry(50000, 64, 64);
  const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: nebulaVS,
    fragmentShader: nebulaFS,
    side: THREE.BackSide,
    transparent: false
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.userData.uniforms = uniforms;
  mesh.visible = true; // 默认显示，在标题界面显示
  
  return mesh;
}

// 创建银河核心
function createTitleGalacticCore() {
  const group = new THREE.Group();
  
  const geometry = new THREE.SphereGeometry(0.05, 32, 32);
  const material = new THREE.MeshBasicMaterial({ color: '#ffeedd', toneMapped: false });
  const mesh = new THREE.Mesh(geometry, material);
  group.add(mesh);
  
  const light = new THREE.PointLight(0xffeedd, 5, 60, 2);
  group.add(light);
  group.userData.light = light;
  group.userData.mesh = mesh;
  group.visible = true; // 默认显示，在标题界面显示
  
  return group;
}

// 初始化标题背景
function initTitleBackground() {
  titleGalaxyParticles = createTitleGalaxyParticles();
  titleOuterGalaxyParticles = createTitleOuterGalaxyParticles();
  titleNebulaBackground = createTitleNebulaBackground();
  titleGalacticCore = createTitleGalacticCore();
  titleDeepStars = createTitleDeepStars();
  
  scene.add(titleGalaxyParticles);
  scene.add(titleOuterGalaxyParticles);
  scene.add(titleNebulaBackground);
  scene.add(titleGalacticCore);
  scene.add(titleDeepStars);
}
// 更新标题背景动画
let lastTitleBackgroundTime = performance.now();
function updateTitleBackground() {
  const now = performance.now();
  const delta = (now - lastTitleBackgroundTime) / 1000;
  lastTitleBackgroundTime = now;
  
  
  // 标题界面、Stage2、Stage3 和 Stage1.5 到 Stage2 的过渡状态都显示星空背景
  if (stage !== 0 && stage !== 2 && stage !== 3 && stage !== "stage1_5To2") {
    // 其他阶段隐藏标题专属背景
    if (titleGalaxyParticles) titleGalaxyParticles.visible = false;
    if (titleOuterGalaxyParticles) titleOuterGalaxyParticles.visible = false;
    if (titleNebulaBackground) titleNebulaBackground.visible = false;
    if (titleGalacticCore) titleGalacticCore.visible = false;
    if (titleDeepStars) titleDeepStars.visible = false;
    return;
  }
  
  // 1. 处理星系粒子 (Galaxy)
  if (titleGalaxyParticles) {
    titleGalaxyParticles.visible = true;
    titleGalaxyRotationSpeed += (titleTargetRotationSpeed - titleGalaxyRotationSpeed) * 0.05;
    
    // 【恢复旧版】warp 期间粒子加速（Z 方向速度提升 3-5 倍）
    let particleSpeedMultiplier = 1.0;
    let particleSizeMultiplier = 1.0;
    let brightnessBoost = 0.0;
    let contrastBoost = 0.0;
    
    if(stage2Warping && stage2WarpStart > 0) {
      const elapsed = now - stage2WarpStart;
      const warpProgress = Math.min(elapsed / 2000, 1); // stage2WarpDuration = 2000
      // 粒子速度提升 4 倍
      particleSpeedMultiplier = 1.0 + warpProgress * 3.0; // 1x → 4x
      // 粒子尺寸增大 20%
      particleSizeMultiplier = 1.0 + warpProgress * 0.2;
      // 亮度提升
      brightnessBoost = warpProgress * 0.8;
      // 对比度提升
      contrastBoost = warpProgress * 0.2;
    }
    
    // 应用粒子加速（通过旋转速度体现）
    const effectiveRotationSpeed = titleGalaxyRotationSpeed * (1.0 + (particleSpeedMultiplier - 1.0) * 0.5);
    titleGalaxyParticles.rotation.y += delta * effectiveRotationSpeed;

    // 【核心修复】Stage 3: 恢复星系亮度 + 保留分层视差
    if(stage === 3 || stage2Warping){
      const relativeDist = 40; // 保持 40 (与 Stage 2 一致)

      // 1. 主星系 (视觉锚点，100% 跟随)
      titleGalaxyParticles.position.copy(camera.position);
      titleGalaxyParticles.position.z -= relativeDist;
      titleGalaxyParticles.frustumCulled = false;
      
      // 【恢复旧版】warp 期间提升亮度和大小
      if(titleGalaxyParticles.material) {
        const baseOpacity = 1.0;
        const baseSize = TITLE_GALAXY_PARAMS.size;
        titleGalaxyParticles.material.opacity = Math.min(baseOpacity + brightnessBoost, 1.0);
        titleGalaxyParticles.material.size = baseSize * particleSizeMultiplier;
      }

      // 2. 外层星星 (98% 跟随，产生视差)
      if(titleOuterGalaxyParticles) {
        titleOuterGalaxyParticles.position.set(
          camera.position.x * 0.98, 
          camera.position.y * 0.98, 
          camera.position.z - relativeDist
        );
        titleOuterGalaxyParticles.frustumCulled = false;
        
        // 呼吸感保留，但基准大小恢复
        const zoomFactor = 1.0 + (1200 - camera.position.z) * 0.0002; 
        titleOuterGalaxyParticles.scale.set(zoomFactor, zoomFactor, zoomFactor);
        
        // 【恢复旧版】warp 期间提升亮度和大小
        if(titleOuterGalaxyParticles.material) {
          const baseOpacity = 0.9;
          const baseSize = OUTER_GALAXY_PARAMS.size;
          titleOuterGalaxyParticles.material.opacity = Math.min(baseOpacity + brightnessBoost, 1.0);
          titleOuterGalaxyParticles.material.size = baseSize * particleSizeMultiplier;
        }
      }

      // 3. 核心光晕
      if(titleGalacticCore) {
        titleGalacticCore.position.copy(camera.position);
        titleGalacticCore.position.z -= relativeDist;
        titleGalacticCore.frustumCulled = false;
        // 恢复亮度
        if(titleGalacticCore.userData.light) titleGalacticCore.userData.light.intensity = 5.0;
      }

      // 4. 深空星星 (95% 跟随)
      if(titleDeepStars){
        titleDeepStars.position.set(
          camera.position.x * 0.95,
          camera.position.y * 0.95,
          camera.position.z - relativeDist
        );
        titleDeepStars.frustumCulled = false;
      }

      // 5. 星云背景
      if(titleNebulaBackground){
        titleNebulaBackground.position.copy(camera.position);
        titleNebulaBackground.position.z -= relativeDist;
        titleNebulaBackground.frustumCulled = false;
      }

    } else {
      // 仅在静止的 Stage 2、标题界面或 Stage1.5 到 Stage2 过渡状态时，才固定在原点
      titleGalaxyParticles.position.set(0, 0, 0);
      titleGalaxyParticles.frustumCulled = true;
      
      if(titleOuterGalaxyParticles) {
        titleOuterGalaxyParticles.position.set(0, 0, 0);
        titleOuterGalaxyParticles.frustumCulled = true;
      }
      if(titleGalacticCore) {
        titleGalacticCore.position.set(0, 0, 0);
        titleGalacticCore.frustumCulled = true;
      }
      if(titleDeepStars) {
        titleDeepStars.position.set(0, 0, 0);
        titleDeepStars.frustumCulled = true;
      }
      if(titleNebulaBackground) {
        titleNebulaBackground.position.set(0, 0, 0);
        titleNebulaBackground.frustumCulled = true;
      }
    }
  }

  // 2. 处理外层星系旋转
  if (titleOuterGalaxyParticles) {
    titleOuterGalaxyParticles.visible = true;
    // 【恢复旧版】warp 期间外层粒子也加速
    let outerSpeedMultiplier = 1.0;
    if(stage2Warping && stage2WarpStart > 0) {
      const elapsed = now - stage2WarpStart;
      const warpProgress = Math.min(elapsed / 2000, 1); // stage2WarpDuration = 2000
      outerSpeedMultiplier = 1.0 + warpProgress * 3.0;
    }
    titleOuterGalaxyParticles.rotation.y += delta * titleGalaxyRotationSpeed * 0.2 * outerSpeedMultiplier;
  }
  
  // 3. 处理深空星星旋转 (保持自转)
  if (titleDeepStars) {
    titleDeepStars.visible = true;
    titleDeepStars.rotation.z += delta * 0.005;
  }
  
  if (titleNebulaBackground) {
    // 【恢复旧版】warp 期间完全隐藏星云（用户要求不要星云效果）
    if (stage2Warping) {
      titleNebulaBackground.visible = false;
    } else if (stage === 2 || stage === 3 || !warpTextState.isActive || !warpTextState.autoMoving) {
      titleNebulaBackground.visible = true;
      const time = now * 0.001;
      titleNebulaBackground.rotation.y = time * 0.02;
      if (titleNebulaBackground.userData.uniforms) {
        titleNebulaBackground.userData.uniforms.uTime.value = time * 0.2;
      }
    } else {
      titleNebulaBackground.visible = false;
    }
  }
  
  if (titleGalacticCore) {
    // Stage2 和 Stage3 时始终显示核心，标题界面时根据 warpTextState 判断
    if (stage === 2 || stage === 3 || !warpTextState.isActive || !warpTextState.autoMoving) {
      titleGalacticCore.visible = true;
      const time = now * 0.001;
      const scale = 1 + Math.sin(time * 2.0) * 0.1;
      if (titleGalacticCore.userData.mesh) {
        titleGalacticCore.userData.mesh.scale.setScalar(scale);
      }
      if (titleGalacticCore.userData.light) {
        titleGalacticCore.userData.light.intensity = 5 + Math.sin(time * 1.5) * 1.5;
        const hue = 0.05 + Math.sin(time * 0.2) * 0.02;
        titleGalacticCore.userData.light.color.setHSL(hue, 0.9, 0.6);
      }
    } else {
      titleGalacticCore.visible = false;
    }
  }
  
  // 更新标题界面相机位置（仅标题界面时）
  if (stage === 0) {
    if (warpTextState.isActive && warpTextState.autoMoving) {
      // 自动向前移动
      titleCameraZ += warpTextState.autoMoveSpeed;
      titleCameraTargetZ = titleCameraZ;
    } else {
      // 手势控制逻辑
      titleWarpSpeed += (targetTitleWarpSpeed - titleWarpSpeed) * 0.1;
      
      if (Math.abs(titleWarpSpeed) > 0.005) {
        titleCameraZ += titleWarpSpeed;
        titleCameraTargetZ = titleCameraZ;
      } else {
        titleCameraZ += (titleCameraTargetZ - titleCameraZ) * 0.08;
      }
    }
    
    // 限制相机范围
    if (titleCameraZ < -100) {
      titleCameraZ = -100;
      titleCameraTargetZ = -100;
    }
    if (titleCameraZ > 100) {
      titleCameraZ = 100;
      titleCameraTargetZ = 100;
    }
    
    // 计算倾斜后的轨迹（6度倾斜）
    const tiltAngle = 6 * (Math.PI / 180);
    const initialZ = 24;
    const y = (initialZ - titleCameraZ) * Math.tan(tiltAngle);
    
    camera.position.set(0, y, titleCameraZ);
    
    // 检测是否需要显示穿越文字
    checkWarpTextTrigger();
  }
}

// 初始化标题背景
initTitleBackground();
function warpStarfield(){}
function rotateDeepSpace(){}
// Stage3：星座
// Stage2 → Stage3 过渡用 3D 影子星座
let shadowConstellation = null;

function buildConstellation3D(poly, savedEdges = null){
  // poly 已经是标准化后的坐标（居中、缩放后的屏幕坐标）
  // 直接转换为 3D 空间坐标，不要再进行二次变换
  
  // 计算屏幕中心（用于将屏幕坐标转换为以原点为中心的 3D 坐标）
  const screenCenterX = W / 2;
  const screenCenterY = H / 2;
  
  // 3D 空间的缩放因子（将屏幕像素转换为 3D 单位）
  // 调整这个值可以控制星座在 3D 空间中的大小
  const scale3D = 0.6;

  // 直接将标准化后的屏幕坐标转换为 3D 坐标
  const pts = poly.map(p => new THREE.Vector3(
    (p.x - screenCenterX) * scale3D,
    -(p.y - screenCenterY) * scale3D,
    (Math.random() * 120 - 60)
  ));

  const group = new THREE.Group();

  // 顶点（星星）
  const pos = [];
  pts.forEach(p => pos.push(p.x, p.y, p.z));
  const g = new THREE.BufferGeometry();
  g.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
  const m = new THREE.PointsMaterial({
    size: 18,
    color: 0xffffff,
    transparent: true,
    opacity: 1,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const points = new THREE.Points(g, m);
  group.add(points);

  // 连接线：如果有保存的连线结构，使用保存的；否则重新计算
  let chosen;
  if(savedEdges && savedEdges.length > 0){
    // 使用保存的连线结构（与stage1一致）
    chosen = savedEdges;
  } else {
    // 重新计算连线（向后兼容，用于没有保存edges的情况）
    // 先将3D点转换为2D点用于计算连线（忽略Z坐标）
    const pts2D = pts.map(p => ({x: p.x, y: p.y}));
    // 使用默认的 maxDistance（基于屏幕尺寸）
    chosen = computeConstellationEdges(pts2D);
  }
  
  const lpos = [];
  for(const e of chosen){
    const a = pts[e.i];
    const b = pts[e.j];
    lpos.push(a.x, a.y, a.z, b.x, b.y, b.z);
  }
  
  const gl = new THREE.BufferGeometry();
  gl.setAttribute("position", new THREE.Float32BufferAttribute(lpos, 3));
  const ml = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.9
  });
  const lines = new THREE.LineSegments(gl, ml);
  group.add(lines);

  // 比之前稍微靠近一些，让最新作品更"靠前"
  group.position.z = -1400;
  group.userData.baseZ = group.position.z;
  group.userData.baseScale = 1.0;
  return group;
}

// Stage2 开始时准备一个"隐藏"的 3D 影子星座
function prepareShadowConstellationForStage2(){
  if(!savedPolygonGlobal || !savedPolygonGlobal.length) return;

  // 先清理旧的影子星座
  if(shadowConstellation){
    scene.remove(shadowConstellation);
    shadowConstellation.traverse(obj => {
      if(obj.geometry) obj.geometry.dispose();
      if(obj.material){
        if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
        else if(obj.material.dispose) obj.material.dispose();
      }
    });
    shadowConstellation = null;
  }

  // 用当前保存的多边形生成 3D 星座，传入保存的连线结构
  shadowConstellation = buildConstellation3D(savedPolygonGlobal, savedConstellationEdges);
  shadowConstellation.visible = false; // Stage2 时隐藏，Warp 和 Stage3 时显示
  shadowConstellation.userData.isShadowConstellation = true;
  scene.add(shadowConstellation);
}
//   手势摄像机
let camTargetX = 0;
let camTargetY = 0;
let camTargetZ = 1200;
const SINGLE_HAND_STATE = {
  filteredX: null, prevFilteredX: null,
  filteredY: null, prevFilteredY: null,
  direction: 0, directionY: 0,
  oppositeFrames: 0, oppositeFramesY: 0,
  idleFrames: 0, idleFramesY: 0
};
const RIGHT_BOUNDARY = {
  threshold: 3500, hardLimit: 3800, resistanceStart: 3500, resistanceEnd: 3800,
  isAtBoundary: false, bounceTarget: 3750, bounceStartTime: 0, isBouncing: false
};
const TOP_BOUNDARY = {
  threshold: -1800, hardLimit: -2200, resistanceStart: -1800, resistanceEnd: -2200,
  isAtBoundary: false, isBouncing: false, bounceTarget: -2000, bounceStartTime: 0
};
const BOTTOM_BOUNDARY = {
  threshold: 1800, hardLimit: 2200, resistanceStart: 1800, resistanceEnd: 2200,
  isAtBoundary: false, isBouncing: false, bounceTarget: 2000, bounceStartTime: 0
};
// 状态变量定义在外面 (保持不变)
let isHandOpenState = false;

function controlCameraByHands(h){
  // 1. 非 Stage 3 或无手数据时重置状态
  if(stage !== 3){
    controlCameraByHands.lastDist = undefined;
    controlCameraByHands.zoomSpeed = 0;
    SINGLE_HAND_STATE.filteredX = null;
    SINGLE_HAND_STATE.prevFilteredX = null;
    SINGLE_HAND_STATE.filteredY = null;
    SINGLE_HAND_STATE.prevFilteredY = null;
    SINGLE_HAND_STATE.direction = 0;
    SINGLE_HAND_STATE.directionY = 0;
    return;
  }
  
  // 如果没有检测到手，彻底重置状态
  if(!h || h.length === 0){
    controlCameraByHands.lastDist = undefined;
    controlCameraByHands.zoomSpeed = 0;
    SINGLE_HAND_STATE.filteredX = null; // 关键：手消失时清除记忆
    SINGLE_HAND_STATE.prevFilteredX = null;
    SINGLE_HAND_STATE.filteredY = null;
    SINGLE_HAND_STATE.prevFilteredY = null;
    SINGLE_HAND_STATE.direction = 0;
    SINGLE_HAND_STATE.directionY = 0;
    return;
  }

  updateActivityTime();
  const ids = [0,5,9,13,17];

    // 单手控制：左右和上下滑动
    if(h.length === 1){
    controlCameraByHands.lastDist = undefined;
    controlCameraByHands.zoomSpeed = 0;

    // 计算手掌中心 X 和 Y (归一化 0.0 ~ 1.0)
    const palmX = (h[0][0].x + h[0][5].x + h[0][9].x + h[0][13].x + h[0][17].x) / 5;
    const palmY = (h[0][0].y + h[0][5].y + h[0][9].y + h[0][13].y + h[0][17].y) / 5;
    const state = SINGLE_HAND_STATE;

    // --- 1. 初始进入判定 ---
    // 如果之前没有记录位置，说明手刚进入画面，直接同步位置，不移动
    if(state.filteredX === null || state.filteredY === null){
      state.filteredX = palmX;
      state.prevFilteredX = palmX;
      state.filteredY = palmY;
      state.prevFilteredY = palmY;
      state.direction = 0;
      state.directionY = 0;
      state.oppositeFrames = 0;
      state.oppositeFramesY = 0;
      state.idleFrames = 0;
      state.idleFramesY = 0;
      return;
    }

    // --- 2. [New] 防跳跃保护 (Teleport Guard) ---
    // 如果当前位置与上一帧位置相差超过 0.08 (屏幕宽度的8%)
    // 我们认为这不是人类能做出的正常滑动速度，而是手位置的突变（换地方升起）
    // 此时强制重置锚点，防止画面跳跃
    const jumpDistX = Math.abs(palmX - state.filteredX);
    const jumpDistY = Math.abs(palmY - state.filteredY);
    if (jumpDistX > 0.08 || jumpDistY > 0.08) {
        state.filteredX = palmX;
        state.prevFilteredX = palmX;
        state.filteredY = palmY;
        state.prevFilteredY = palmY;
        return;
    }

    // --- 3. 手指伸展度判定 (你之前的逻辑) ---
    const hand = h[0];
    const wrist = hand[0];
    const fingerTips = [8, 12, 16];
    const fingerMCPs = [5, 9, 13];
    
    let extendedCount = 0;
    for(let i=0; i<fingerTips.length; i++){
        const tip = hand[fingerTips[i]];
        const mcp = hand[fingerMCPs[i]];
        const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
        const distMCP = Math.hypot(mcp.x - wrist.x, mcp.y - wrist.y);
        if(distTip > distMCP * 1.5) {
            extendedCount++;
        }
    }

    // 迟滞阈值
    if (extendedCount >= 3) {
        isHandOpenState = true;
    } else if (extendedCount <= 1) {
        isHandOpenState = false;
    }

    // --- 4. 平滑与移动计算 ---
    const SMOOTH = 0.28;
    // 平滑位置（X和Y）
    state.filteredX = THREE.MathUtils.lerp(state.filteredX, palmX, SMOOTH);
    state.filteredY = THREE.MathUtils.lerp(state.filteredY, palmY, SMOOTH);
    
    // 计算位移量（X和Y）
    const deltaX = state.filteredX - state.prevFilteredX;
    const deltaY = state.filteredY - state.prevFilteredY;
    
    // 关键：始终更新基准点，确保无论手张开还是闭合，系统都在跟踪
    state.prevFilteredX = state.filteredX;
    state.prevFilteredY = state.filteredY;

    // 只有手张开时才移动相机
    if (isHandOpenState) {
        document.body.style.cursor = "move";
        
        const DEADZONE = 0.002; // 稍微调小了一点死区让手感更灵敏
        const hasMovementX = Math.abs(deltaX) >= DEADZONE;
        const hasMovementY = Math.abs(deltaY) >= DEADZONE;
        
        // X轴移动处理
        if(hasMovementX){
            state.idleFrames = 0;
        const RELATIVE_SENSITIVITY = 9200;
            const dir = deltaX > 0 ? 1 : -1;

        // 方向防抖
        const OPPOSITE_HOLD_FRAMES = 6;
        if(state.direction === 0){
            state.direction = dir;
            state.oppositeFrames = 0;
        }else if(dir !== state.direction){
            state.oppositeFrames++;
                if(state.oppositeFrames < OPPOSITE_HOLD_FRAMES) {
                    // 等待防抖，但不阻止Y轴移动
                } else {
            state.direction = dir;
            state.oppositeFrames = 0;
                }
        }else{
            state.oppositeFrames = 0;
        }

            if(!RIGHT_BOUNDARY.isBouncing){
                // 应用X轴移动
                let moveAmountX = deltaX * RELATIVE_SENSITIVITY;
        // 阻力计算
                if(deltaX > 0 && camTargetX >= RIGHT_BOUNDARY.resistanceStart){
            const progress = (camTargetX - RIGHT_BOUNDARY.resistanceStart) / (RIGHT_BOUNDARY.resistanceEnd - RIGHT_BOUNDARY.resistanceStart);
            const resistance = Math.min(1, progress);
            const resistanceFactor = 1 - Math.pow(resistance, 1.5) * 0.95;
                    moveAmountX *= resistanceFactor;
        }

                const newTargetX = camTargetX + moveAmountX;
        
                // X轴边界处理
        if(newTargetX >= RIGHT_BOUNDARY.hardLimit){
             if(!RIGHT_BOUNDARY.isAtBoundary){
                RIGHT_BOUNDARY.isAtBoundary = true;
                RIGHT_BOUNDARY.isBouncing = true;
                RIGHT_BOUNDARY.bounceStartTime = performance.now();
             }
             if(!RIGHT_BOUNDARY.isBouncing) camTargetX = RIGHT_BOUNDARY.hardLimit;
        } else {
             camTargetX = Math.max(-3800, Math.min(3800, newTargetX));
             if(camTargetX < RIGHT_BOUNDARY.resistanceStart){
                RIGHT_BOUNDARY.isAtBoundary = false;
                RIGHT_BOUNDARY.isBouncing = false;
                     }
                }
            }
        } else {
            state.idleFrames++;
            if(state.idleFrames > 12) state.direction = 0;
        }
    } else {
        document.body.style.cursor = "default";
    }
    return;
  }

    // 双手控制：缩放 (Zoom) - 保持不变
    function center(hand){
    let x=0, y=0;
    for(let id of ids){ x += hand[id].x; y += hand[id].y; }
    return {x:x/ids.length, y:y/ids.length};
  }
  let c1 = center(h[0]), c2 = center(h[1]);
  let distNow = Math.hypot(c1.x - c2.x, c1.y - c2.y);
  if(controlCameraByHands.lastDist === undefined){
    controlCameraByHands.lastDist = distNow;
    return;
  }
  let dDist = distNow - controlCameraByHands.lastDist;
  const DISTANCE_TOLERANCE = 0.005;
  if (Math.abs(dDist) < DISTANCE_TOLERANCE){
    controlCameraByHands.zoomSpeed = 0;
    controlCameraByHands.lastDist = distNow;
    return;
  }
  updateActivityTime();
  let speed = dDist * 6000;
  camTargetZ -= speed;
  // Stage3 的 z 轴限制为 [-5000, 6000]，其他阶段保持原有限制
  if(stage === 3){
    camTargetZ = THREE.MathUtils.clamp(camTargetZ, -5000, 6000);
  } else {
    camTargetZ = THREE.MathUtils.clamp(camTargetZ, -30000, 5200);
  }
  controlCameraByHands.zoomSpeed = speed;
  controlCameraByHands.lastDist = distNow;
}
function updateCamera(){
  // Stage3的右边界弹跳处理
  if(RIGHT_BOUNDARY.isBouncing && stage === 3){
    const now = performance.now();
    const bounceElapsed = now - RIGHT_BOUNDARY.bounceStartTime;
    const bounceDuration = 400;
    if(bounceElapsed < bounceDuration){
      const t = bounceElapsed / bounceDuration;
      const ease = 1 - Math.pow(1 - t, 3);
      camTargetX = THREE.MathUtils.lerp(RIGHT_BOUNDARY.hardLimit, RIGHT_BOUNDARY.bounceTarget, ease);
    } else {
      RIGHT_BOUNDARY.isBouncing = false;
      camTargetX = RIGHT_BOUNDARY.bounceTarget;
    }
  }
  
  // 标题界面的相机位置更新（在updateTitleBackground中处理）
  if(stage === 0){
    // 相机位置已在updateTitleBackground中更新
    // 更新提示显示（仅在标题界面显示）
    const instructionText = document.getElementById("instructionText");
    if(instructionText){
      if(!warpTextState.isActive){
        instructionText.style.display = "block";
        instructionText.style.opacity = "0.85";
      } else {
        instructionText.style.display = "none";
      }
    }
  } else if(stage === 2 && !stage2Warping){
    // 只有 Stage2 且不在 Warp 阶段时，才把相机固定在标题初始位置
    const tiltAngle = 6 * (Math.PI / 180);
    const initialZ = 40;
    const y = (initialZ - initialZ) * Math.tan(tiltAngle); // y = 0
    camera.position.set(0, y, initialZ);
  } else {
    // 其它情况下（包括 Stage3，以及 Stage2 的 Warp 阶段），按照 camTargetX/Y/Z 做平滑插值
    // 注意：Warp 阶段时，相机位置由 stage2Warping 逻辑控制，这里只处理非 Warp 的情况
    if(stage !== 2 || !stage2Warping){
      camera.position.x = THREE.MathUtils.lerp(camera.position.x, camTargetX, 0.12);
      // Stage 3 禁用 Y 轴移动，保持相机 Y 轴固定
      if(stage !== 3){
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, camTargetY, 0.12);
      }
      camera.position.z = THREE.MathUtils.lerp(camera.position.z, camTargetZ, 0.06);
    }

    if(stage === 3){
      const boundaryHint = document.getElementById("stage3BoundaryHint");
      if(boundaryHint){
        boundaryHint.style.display = "none";
      }
    }
  }
}

// 画廊与保存逻辑
let creations = [];
// === IndexedDB 配置 ===
const DB_NAME = "StarProjectDB";
const DB_VERSION = 1;
const STORE_NAME = "constellations";

// 打开数据库助手函数
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: "id" });
      }
    };
    request.onsuccess = (event) => resolve(event.target.result);
    request.onerror = (event) => reject(event.target.error);
  });
}

// === 新的保存函数 (IndexedDB版) ===
async function saveCreationsToStorage() {
  try {
    const db = await openDB();
    const transaction = db.transaction([STORE_NAME], "readwrite");
    const store = transaction.objectStore(STORE_NAME);

    // 准备数据 (注意：增加了 edges 字段以修复连线丢失问题)
    const dataToSave = creations.map(c => ({
      id: c.id,
      dateStr: c.dateStr,
      thumb: c.thumb,
      poly: c.poly,
      edges: c.edges, // 重要：保存连线结构
      strokePolylines: normalizeStrokePolylines(c.strokePolylines || c.strokePoints)
    }));

    store.clear(); // 清除旧数据，进行全量更新
    dataToSave.forEach(item => {
      store.put(item);
    });

    transaction.oncomplete = () => {
      console.log(`Saved ${dataToSave.length} items to IndexedDB.`);
    };
    transaction.onerror = (e) => {
      console.error("IndexedDB Save Error:", e);
    };

  } catch (e) {
    console.error("Save failed:", e);
    alert("保存に失敗しました。(IndexedDB Error)");
  }
}

// === 新的读取函数 (IndexedDB版) ===
async function loadCreationsFromStorage() {
  try {
    const db = await openDB();
    const transaction = db.transaction([STORE_NAME], "readonly");
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();

    request.onsuccess = () => {
      const arr = request.result;
      if (!Array.isArray(arr) || arr.length === 0) return;

      const inner = document.getElementById("galleryInner");
      inner.innerHTML = "";
      creations = []; 

      // 按ID排序
      arr.sort((a, b) => a.id - b.id);

      for (let r of arr) {
        const rec = {
          id: r.id,
          dateStr: r.dateStr,
          thumb: r.thumb,
          poly: r.poly || [],
          edges: r.edges || [], // 恢复连线
          strokePolylines: normalizeStrokePolylines(r.strokePolylines || r.strokePoints)
        };
        creations.push(rec);
        addGalleryTile(rec);
      }
      layoutCreationsInScene();
      console.log(`Loaded ${creations.length} items from IndexedDB.`);
    };
  } catch (e) {
    console.error("Load failed:", e);
  }
}
function captureThumbnail(width = 600, height = 360){
  const srcCanvas = renderer.domElement;
  const tmp = document.createElement("canvas");
  tmp.width = width; tmp.height = height;
  const tctx = tmp.getContext("2d");
  // 先画 3D 星空，再叠加 2D 画布（艺术层和 UI 层，即使被隐藏，内容依然存在）
  tctx.drawImage(srcCanvas, 0, 0, width, height);
  tctx.drawImage(artCanvas, 0, 0, width, height);
  tctx.drawImage(uiCanvas, 0, 0, width, height);
  return tmp.toDataURL("image/jpeg", 0.85);
}
function layoutCreationsInScene(){
  if(creations.length === 0) return;
  const latest = creations[creations.length-1];
  
  // 计算相机可见范围
  // 相机 FOV = 60度，相机位置约在 Z = 24，Y = 0（Stage 3 相机 Y 轴固定）
  // 星座位置约在 Z = -1800
  // 距离 = 24 - (-1800) = 1824
  // 可见的垂直范围 = 2 * distance * tan(FOV/2) = 2 * 1824 * tan(30°) ≈ 2105
  // 为了安全，使用 75% 的可见范围，确保星座不会太靠近边缘，并且居中分布
  const CAMERA_Z = 24; // Stage 3 相机 Z 位置
  const CAMERA_Y = 0; // Stage 3 相机 Y 位置（固定）
  const CONSTELLATION_Z = -1800; // 星座的典型 Z 位置
  const DISTANCE = CAMERA_Z - CONSTELLATION_Z; // 约 1824
  const FOV = 60 * (Math.PI / 180); // 60度转弧度
  const VISIBLE_HEIGHT = 2 * DISTANCE * Math.tan(FOV / 2); // 约 2105
  // 使用 75% 的可见范围，确保星座不会太靠近边缘，并且居中分布
  const SAFE_Y_RANGE = VISIBLE_HEIGHT * 0.5; // 约 1579，范围从 -790 到 790
  
  // 空间范围定义
  const X_RANGE = 6800;  // X轴范围：-3400 到 3400（保持原样，支持左右滑动）
  const Y_RANGE = SAFE_Y_RANGE;  // Y轴范围：限制在相机可见范围内（约 -842 到 842）
  const Z_RANGE = 800;   // Z轴范围：-1600 到 -2400
  const Z_START = -1600;
  
  // 最新星座放在中心位置
  if(latest && latest.group){
    latest.group.position.x = 0;
    latest.group.position.y = 0;
    latest.group.position.z = -1800;
  }
  
  // 其他星座使用改进的均匀分布算法
  const others = creations.filter(c => c !== latest && c.group);
  if(others.length === 0) return;
  
  // 分布范围定义 - 扩大X范围以利用整个可移动空间
  const X_MIN = -3200;  // 扩大到接近可移动范围边界
  const X_MAX = 3200;
  const Y_MIN = -900;
  const Y_MAX = 900;
  const Z_CENTER = -1800; // Z 轴中心位置（与最新星座一致）
  const Z_RANDOM_RANGE = 100; // Z 轴随机范围：-100 到 100
  
  // 最小距离 - 根据可用空间和星座数量动态调整
  // 计算可用空间面积
  const availableArea = (X_MAX - X_MIN) * (Y_MAX - Y_MIN);
  // 估算每个星座需要的空间（圆形区域，半径约400）
  const spacePerConstellation = Math.PI * 400 * 400;
  // 计算理想的最小距离（确保不会太挤也不会太散）
  const idealMinDist = Math.sqrt(availableArea / (others.length * 1.2)) * 0.8;
  // 限制在合理范围内
  const minDist = Math.max(450, Math.min(700, idealMinDist));
  
  // 使用改进的均匀分布算法：网格初始分布 + 随机扰动
  const positions = [];
  const totalCount = others.length;
  const maxAttempts = 150; // 增加尝试次数以获得更好的分布
  
  // 最新星座的中心位置（需要避免重合）
  const latestPos = { x: 0, y: 0, z: -1800 };
  
  // 计算网格尺寸，使分布更均匀
  const gridCols = Math.ceil(Math.sqrt(totalCount * 1.5)); // 稍微多一点的列数
  const gridRows = Math.ceil(totalCount / gridCols);
  const cellWidth = (X_MAX - X_MIN) / gridCols;
  const cellHeight = (Y_MAX - Y_MIN) / gridRows;
  
  // 创建候选位置列表（基于网格）
  const candidates = [];
  for(let row = 0; row < gridRows; row++){
    for(let col = 0; col < gridCols; col++){
      const baseX = X_MIN + (col + 0.5) * cellWidth;
      const baseY = Y_MIN + (row + 0.5) * cellHeight;
      // 添加随机扰动（不超过单元格的30%）
      const x = baseX + (Math.random() - 0.5) * cellWidth * 0.3;
      const y = baseY + (Math.random() - 0.5) * cellHeight * 0.3;
      candidates.push({ x, y });
    }
  }
  
  // 打乱候选位置顺序
  for(let i = candidates.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
  }
  
  // 从候选位置中选择满足距离要求的位置
  for(let i = 0; i < totalCount; i++){
    let attempts = 0;
    let valid = false;
    let newPos = null;
    
    // 优先使用网格候选位置
    let candidateIndex = 0;
    
    do {
      let x, y;
      
      // 前80%的尝试使用网格候选位置，后20%使用完全随机
      if(attempts < maxAttempts * 0.8 && candidateIndex < candidates.length){
        const candidate = candidates[candidateIndex];
        x = candidate.x;
        y = candidate.y;
        candidateIndex++;
      } else {
        // 完全随机位置
        x = X_MIN + Math.random() * (X_MAX - X_MIN);
        y = Y_MIN + Math.random() * (Y_MAX - Y_MIN);
      }
      
      // Z 轴轻微随机（-100 到 100）
      const z = Z_CENTER + (Math.random() - 0.5) * Z_RANDOM_RANGE * 2;
      
      newPos = { x, y, z };
      valid = true;
      
      // 首先检查与最新星座（中心位置）的距离
      const distToLatest = Math.sqrt(
        Math.pow(newPos.x - latestPos.x, 2) +
        Math.pow(newPos.y - latestPos.y, 2)
      );
      if(distToLatest < minDist){
        valid = false;
      }
      
      // 然后检查与已有位置的距离
      if(valid){
        for(let pos of positions){
          // 只检查 X、Y 距离（Z 轴距离不参与判断，因为主要是 XY 平面分布）
          const dist = Math.sqrt(
            Math.pow(newPos.x - pos.x, 2) +
            Math.pow(newPos.y - pos.y, 2)
          );
          if(dist < minDist){
            valid = false;
            break;
          }
        }
      }
      
      attempts++;
      
      // 如果尝试次数过多，放宽距离要求（避免无限循环）
      if(attempts > maxAttempts){
        // 降低最小距离要求到 75%
        const relaxedMinDist = minDist * 0.75;
        valid = true;
        
        // 检查与最新星座的距离（放宽后）
        const distToLatestRelaxed = Math.sqrt(
          Math.pow(newPos.x - latestPos.x, 2) +
          Math.pow(newPos.y - latestPos.y, 2)
        );
        if(distToLatestRelaxed < relaxedMinDist){
          valid = false;
        }
        
        // 检查与已有位置的距离（放宽后）
        if(valid){
          for(let pos of positions){
            const dist = Math.sqrt(
              Math.pow(newPos.x - pos.x, 2) +
              Math.pow(newPos.y - pos.y, 2)
            );
            if(dist < relaxedMinDist){
              valid = false;
              break;
            }
          }
        }
        if(valid) break; // 如果满足放宽后的要求，接受这个位置
      }
    } while(!valid && attempts < maxAttempts * 2);
    
    // 如果找到了有效位置，添加到列表
    if(newPos && valid){
      positions.push(newPos);
    } else {
      // 如果实在找不到，使用随机位置（但仍在范围内，并确保不与中心星座重合）
      let fallbackPos;
      let fallbackAttempts = 0;
      do {
        fallbackPos = {
          x: X_MIN + Math.random() * (X_MAX - X_MIN),
          y: Y_MIN + Math.random() * (Y_MAX - Y_MIN),
          z: Z_CENTER + (Math.random() - 0.5) * Z_RANDOM_RANGE * 2
        };
        // 检查与中心星座的距离
        const distToLatest = Math.sqrt(
          Math.pow(fallbackPos.x - latestPos.x, 2) +
          Math.pow(fallbackPos.y - latestPos.y, 2)
        );
        // 检查与已有位置的距离
        let tooClose = false;
        for(let pos of positions){
          const dist = Math.sqrt(
            Math.pow(fallbackPos.x - pos.x, 2) +
            Math.pow(fallbackPos.y - pos.y, 2)
          );
          if(dist < minDist * 0.5){
            tooClose = true;
            break;
          }
        }
        fallbackAttempts++;
        // 如果距离足够远，或者尝试次数过多（避免无限循环），接受这个位置
        if((distToLatest >= minDist * 0.5 && !tooClose) || fallbackAttempts >= 50) break;
      } while(fallbackAttempts < 50);
      positions.push(fallbackPos);
    }
  }
  
  // 应用位置到星座
  others.forEach((c, idx) => {
    if(c.group && positions[idx]){
      c.group.position.x = positions[idx].x;
      c.group.position.y = positions[idx].y;
      c.group.position.z = positions[idx].z;
    }
  });
}
function addCreationToScene(rec){
  // 传入保存的连线结构（如果存在），确保与stage1的连线方式一致
  const grp = buildConstellation3D(rec.poly, rec.edges || null);
  const strokeSets = normalizeStrokePolylines(rec.strokePolylines || rec.strokePoints);
  rec.strokePolylines = strokeSets;
  if(strokeSets.length){
    const strokeGroup = new THREE.Group();
    for(let path of strokeSets){
      if(path.length < 2) continue;
      const positions = [];
      for(let p of path){
        positions.push((p.x - W/2) * 0.6, -(p.y - H/2) * 0.6, -20);
      }
      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
      const mat = new THREE.LineBasicMaterial({ color: 0xffe6cc, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending });
      const line = new THREE.Line(geom, mat);
      line.position.z = 0;
      strokeGroup.add(line);
    }
    if(strokeGroup.children.length){
      grp.add(strokeGroup);
      grp.userData.strokeLine = strokeGroup;
    }
  }
  grp.userData.isUserCreation = true;
  grp.userData.creationId = rec.id;
  scene.add(grp);
  rec.group = grp;
}
function addGalleryTile(rec){
  const inner = document.getElementById("galleryInner");
  const tile = document.createElement("div");
  tile.className = "galleryTile";
  tile.innerHTML = `<img src="${rec.thumb}" /><div class="galleryMeta">${rec.dateStr}</div><button class="galleryDel">削除</button>`;
  inner.appendChild(tile);
  const delBtn = tile.querySelector(".galleryDel");
  delBtn.addEventListener("click", ()=>{
    updateActivityTime();
    if(!confirm("この作品を削除しますか？")) return;
    
    // 1. 从场景移除
    if(rec.group){
      scene.remove(rec.group);
      rec.group.traverse(obj=>{
        if(obj.geometry) obj.geometry.dispose();
        if(obj.material) { if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose(); }
      });
    }
    
    // 2. 从内存数组移除
    const idx = creations.findIndex(c=>c.id === rec.id);
    if(idx>=0) creations.splice(idx,1);
    
    // 3. 移除 DOM
    tile.remove();
    
    // 4. 重新布局 3D 场景
    layoutCreationsInScene();
    
    // 5. 保存更改到 IndexedDB
    saveCreationsToStorage(); 
  });
}
document.getElementById("galleryBtn").addEventListener("click", ()=>{ 
  updateActivityTime(); // 点击按钮时更新活动时间
  document.getElementById("galleryOverlay").style.display = "block"; 
});
document.querySelector("#galleryOverlay .closeBtn").addEventListener("click", ()=>{ 
  updateActivityTime(); // 点击按钮时更新活动时间
  document.getElementById("galleryOverlay").style.display = "none"; 
});
loadCreationsFromStorage();

// 标题手势 & Title Warp
//   穿越文字显示函数
let lastWarpTextUpdate = 0;
function checkWarpTextTrigger() {
  if(stage !== 0) return;
  
  const z = titleCameraZ;
  const [minZ, maxZ] = warpTextState.triggerZRange;
  
  // 标题BGM淡出逻辑：当接近触发位置时开始淡出
  const titleBGM = document.getElementById("titleBGM");
  if (titleBGM && !warpTextState.isActive) {
    // 触发范围是 [-5, 12]，在接近这个范围时开始淡出
    // 当 z 在 [8, 15] 范围内时开始淡出（在触发范围前开始）
    const fadeStartZ = 15; // 开始淡出的Z位置
    const fadeEndZ = minZ; // 完全静音的Z位置（-5）
    
    if (z <= fadeStartZ && z >= fadeEndZ) {
      // 计算音量：从1.0淡出到0.0
      const fadeRange = fadeStartZ - fadeEndZ; // 15 - (-5) = 20
      const fadeProgress = (z - fadeEndZ) / fadeRange; // 0到1之间
      titleBGM.volume = Math.max(0, Math.min(1, fadeProgress));
    } else if (z < fadeEndZ) {
      // 已经进入触发范围，完全静音
      titleBGM.volume = 0;
    } else {
      // 远离触发范围，正常音量
      titleBGM.volume = 1.0;
    }
  }
  
  // 检测是否在触发范围内
  if (z >= minZ && z <= maxZ && !warpTextState.isActive) {
    startWarpTextSequence();
  }
  
  // 如果文字显示已激活，继续更新
  if (warpTextState.isActive) {
    const now = performance.now();
    if (now - lastWarpTextUpdate >= 16) {
      updateWarpText();
      lastWarpTextUpdate = now;
    }
  }
}

function startWarpTextSequence() {
  // 停止标题BGM
  const titleBGM = document.getElementById("titleBGM");
  if (titleBGM) {
    titleBGM.pause();
    titleBGM.currentTime = 0;
  }
  
  // 播放BGM
  const bgm = document.getElementById("introBGM");
  if (bgm) {
    bgm.currentTime = 0;
    bgm.volume = 0.8;
    bgm.play().catch(e => console.log("BGM播放失败:", e));
  }
  
  warpTextState.isActive = true;
  warpTextState.currentLineIndex = 0;
  warpTextState.currentCharIndex = 0;
  warpTextState.lastUpdateTime = performance.now();
  warpTextState.autoMoving = true;
  
  // 显示遮罩
  const overlay = document.getElementById('warpOverlay');
  const container = document.getElementById('warpTextContainer');
  if (overlay) {
    overlay.style.display = 'block';
    overlay.style.opacity = '0';
    setTimeout(() => {
      overlay.style.opacity = '1';
    }, 10);
  }
  if (container) container.style.display = 'block';
  
  // 隐藏标题
  const titleContainer = document.getElementById('titleOverlay');
  if (titleContainer) {
    titleContainer.style.transition = 'opacity 1.5s ease-out';
    titleContainer.style.opacity = '0';
  }
  
  // 隐藏提示文字
  const instructionText = document.getElementById('instructionText');
  if (instructionText) {
    instructionText.style.transition = 'opacity 1.5s ease-out';
    instructionText.style.opacity = '0';
  }
}

function updateWarpText() {
  if (!warpTextState.isActive || stage !== 0) return;
  
  const now = performance.now();
  const { currentLineIndex, currentCharIndex, charInterval, lineInterval } = warpTextState;
  
  if (currentLineIndex >= WARP_TEXT_MESSAGES.length) {
    // 所有文字显示完成，进入stage1
    setTimeout(() => {
      enterStage1FromTitle();
    }, 2000); // 等待2秒后进入stage1
    return;
  }
  
  const currentLine = WARP_TEXT_MESSAGES[currentLineIndex];
  
  // 检查是否需要显示下一个字符
  if (currentCharIndex < currentLine.length) {
    // 检查前一个字符是否是特定位置的顿号（顿号后暂停）
    const prevChar = currentCharIndex > 0 ? currentLine[currentCharIndex - 1] : '';
    const isAfterTargetPause = prevChar === '、' && 
      ((currentLineIndex === 1 && currentCharIndex === 4) ||  // "ここは、" 后的字符（索引1，位置4）
       (currentLineIndex === 3 && currentCharIndex === 5) ||  // "ここでは、" 后的字符（索引3，位置5）
       (currentLineIndex === 4 && currentCharIndex === 4));    // "まずは、" 后的字符（索引4，位置4）
    
    // 如果是顿号后的字符，需要额外等待时间
    const pauseDelay = isAfterTargetPause ? 300 : 0; // 顿号后暂停0.8秒
    const effectiveInterval = charInterval + pauseDelay;
    
    if (now - warpTextState.lastUpdateTime >= effectiveInterval) {
      displayWarpTextChar(currentLineIndex, currentCharIndex + 1);
      warpTextState.currentCharIndex++;
      warpTextState.lastUpdateTime = now;
    }
  } else {
    // 当前行显示完成，等待后显示下一行
    // 使用对应标语的间隔时间，如果数组未定义则使用默认值
    const currentLineInterval = (LINE_INTERVALS && LINE_INTERVALS[currentLineIndex] !== undefined) 
      ? LINE_INTERVALS[currentLineIndex] 
      : lineInterval;
    
    if (now - warpTextState.lastUpdateTime >= currentLineInterval) {
      fadeUpCurrentLine(currentLineIndex);
      
      // 准备下一行
      warpTextState.currentLineIndex++;
      warpTextState.currentCharIndex = 0;
      warpTextState.lastUpdateTime = now;
    }
  }
}

function displayWarpTextChar(lineIndex, charCount) {
  const container = document.getElementById('warpTextContainer');
  if (!container) return;
  
  const currentLine = WARP_TEXT_MESSAGES[lineIndex];
  const textToShow = currentLine.substring(0, charCount);
  
  // 移除旧的该行元素
  const oldLine = container.querySelector(`.warpTextLine[data-line="${lineIndex}"]`);
  if (oldLine) oldLine.remove();
  
  // 创建新的行元素
  const lineEl = document.createElement('div');
  lineEl.className = 'warpTextLine';
  lineEl.setAttribute('data-line', lineIndex);
  lineEl.innerHTML = textToShow;
  lineEl.style.transform = 'translateX(-50%)';
  lineEl.dataset.translateY = '0';
  container.appendChild(lineEl);
  
  // 当显示"かつて人々"这句标语（lineIndex === 2）的第一个字符时，开始显示star图片序列
  if (lineIndex === 2 && charCount === 1) {
    startStarImageSequence();
  }
}

// Star图片序列显示函数
let starImageSequenceTimer = null;
function startStarImageSequence() {
  // 清除可能存在的定时器
  if (starImageSequenceTimer) {
    clearTimeout(starImageSequenceTimer);
    starImageSequenceTimer = null;
  }
  
  const star1 = document.getElementById('star1Image');
  const star2 = document.getElementById('star2Image');
  const star3 = document.getElementById('star3Image');
  
  if (!star1 || !star2 || !star3) return;
  
  // 重置所有图片状态
  star1.classList.remove('visible');
  star2.classList.remove('visible');
  star3.classList.remove('visible');
  star1.style.display = 'none';
  star2.style.display = 'none';
  star3.style.display = 'none';
  
  // 显示star1，淡入
  star1.style.display = 'block';
  void star1.offsetWidth; // 强制重排
  star1.classList.add('visible');
  
  // 播放star1音效
  const star1Sound = document.getElementById('star1Sound');
  if (star1Sound) {
    star1Sound.volume = 0.3; // 设置音量为60%
    star1Sound.currentTime = 0; // 重置到开头
    star1Sound.play().catch(err => console.log('star1音效播放失败:', err));
  }
  
  // 2秒后显示star2，叠加在star1上
  starImageSequenceTimer = setTimeout(() => {
    star2.style.display = 'block';
    void star2.offsetWidth;
    star2.classList.add('visible');
    
    // 播放star2音效
    const star2Sound = document.getElementById('star2Sound');
    if (star2Sound) {
      star2Sound.volume = 0.3; // 设置音量为60%
      star2Sound.currentTime = 0; // 重置到开头
      star2Sound.play().catch(err => console.log('star2音效播放失败:', err));
    }
    
    // 再2秒后显示star3，叠加在star1和star2上
    starImageSequenceTimer = setTimeout(() => {
      star3.style.display = 'block';
      void star3.offsetWidth;
      star3.classList.add('visible');
      
      // 播放star3音效
      const star3Sound = document.getElementById('star3Sound');
      if (star3Sound) {
        star3Sound.volume = 0.3; // 设置音量为60%
        star3Sound.currentTime = 0; // 重置到开头
        star3Sound.play().catch(err => console.log('star3音效播放失败:', err));
      }
      
      // 再2秒后，所有图片一起淡出消失
      starImageSequenceTimer = setTimeout(() => {
        star1.classList.remove('visible');
        star2.classList.remove('visible');
        star3.classList.remove('visible');
        
        // 等待淡出动画完成后隐藏
        setTimeout(() => {
          star1.style.display = 'none';
          star2.style.display = 'none';
          star3.style.display = 'none';
        }, 1500); // 和淡出动画时间一致
      }, 2000); // star3显示2秒后淡出
    }, 2000); // star2显示2秒后显示star3
  }, 2000); // star1显示2秒后显示star2
}

function fadeUpCurrentLine(lineIndex) {
  const container = document.getElementById('warpTextContainer');
  if (!container) return;
  
  const LINE_SPACING = 6; // vmin
  const upShiftDistance = -LINE_SPACING;
  const FADE_OUT_DELAY = 5000; // 5秒后完全消失
  const isLastLine = lineIndex === 4; // 最后一句（索引4）原地淡出，不上滑
  
  const lineEl = container.querySelector(`.warpTextLine[data-line="${lineIndex}"]`);
  if (lineEl && !lineEl.classList.contains('fadeUp')) {
    // 最后一句不上滑，只淡出
    if (!isLastLine) {
      // 先上移
      const currentY = parseFloat(lineEl.dataset.translateY || '0');
      const newY = currentY + upShiftDistance;
      lineEl.style.transform = `translateX(-50%) translateY(${newY}vmin)`;
      lineEl.dataset.translateY = newY;
    }
    
    // 然后添加淡出效果（会触发CSS transition，5秒内逐渐淡出）
    lineEl.classList.add('fadeUp');
    
    // 5秒后完全移除该行
    setTimeout(() => {
      if (lineEl.parentNode) {
        lineEl.remove();
      }
    }, FADE_OUT_DELAY);
  }
  
  // 所有已经上移的行都要再上移一行（最后一句除外）
  if (!isLastLine) {
    const allLines = container.querySelectorAll('.warpTextLine.fadeUp');
    allLines.forEach((line) => {
      const idx = parseInt(line.getAttribute('data-line'));
      if (idx < lineIndex && idx !== 4) { // 最后一句（索引4）不上移
        const currentY = parseFloat(line.dataset.translateY || '0');
        const newY = currentY + upShiftDistance;
        line.style.transform = `translateX(-50%) translateY(${newY}vmin)`;
        line.dataset.translateY = newY;
      }
    });
  }
}

function enterStage1FromTitle() {
  // 停止标题BGM（离开标题界面时）
  const titleBGM = document.getElementById("titleBGM");
  if (titleBGM) {
    titleBGM.pause();
    titleBGM.currentTime = 0;
  }
  
  // 重置穿越文字状态
  warpTextState.isActive = false;
  warpTextState.autoMoving = false;
  
  // 隐藏遮罩和文字容器
  const overlay = document.getElementById('warpOverlay');
  const container = document.getElementById('warpTextContainer');
  if (overlay) {
    overlay.style.opacity = '0';
    setTimeout(() => {
      overlay.style.display = 'none';
    }, 1500);
  }
  if (container) {
    container.innerHTML = '';
    container.style.display = 'none';
  }
  
  // 隐藏标题覆盖层
  const titleOverlay = document.getElementById('titleOverlay');
  if (titleOverlay) {
    titleOverlay.style.display = 'none';
  }
  
  // 进入stage1
  stage = 1;
  stage1StartTime = 0;
  stage1Opacity = 0;
  stage1AppearStart = performance.now();
  stage1AppearDuration = 1000;
  lastSecondPolygon = null;
  latestValidPolygon = null;
  
  // 重置标语序列状态
  stage1TipSequenceState = "waiting";
  stage1GestureDetectionStartTime = 0;
  if(stage1TipSequenceTimer) {
    clearTimeout(stage1TipSequenceTimer);
    stage1TipSequenceTimer = null;
  }
  
  // 重置相机位置
  camera.position.set(0, 0, 1200);
  camTargetX = 0;
  camTargetY = 0;
  camTargetZ = 1200;
  
  // 显示视频背景
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.add("stage1Visible");
  }
  
  // 显示画布
  artCanvas.style.display = "block";
  uiCanvas.style.display = "block";
  
  // 启动聚集动画
  startParticleCallAnimation();
  
  // 隐藏提示文字（进入stage1时不应显示）
  const instructionText = document.getElementById("instructionText");
  if(instructionText) {
    instructionText.style.display = "none";
  }
  
  // 开始显示标语序列
  showStage1TipSequence();
  
  updateActivityTime(); // 进入 stage 时更新活动时间
}

//   标题手势检测
function detectTitleHands() {
  if(stage !== 0) return;
  if(!handsData || handsData.length === 0) {
    targetTitleWarpSpeed = 0;
    return;
  }
  
  // 单手控制：手掌张开/握拳控制穿越速度
  if(handsData.length === 1) {
    const hand = handsData[0];
    
    // 检测手掌是否张开
    const wrist = hand[0];
    const palmCenter = hand[9];
    const dx = wrist.x - palmCenter.x;
    const dy = wrist.y - palmCenter.y;
    const handSize = Math.sqrt(dx * dx + dy * dy);
    
    const getDist = (p1, p2) => {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    
    // 检测手指是否张开
    let openCount = 0;
    const longFingers = [8, 12, 16];
    longFingers.forEach(tipIdx => {
      if (getDist(hand[tipIdx], wrist) > handSize * 1.6) {
        openCount++;
      }
    });
    if (getDist(hand[20], wrist) > handSize * 1.4) {
      openCount++;
    }
    if (getDist(hand[4], hand[17]) > handSize * 1.2) {
      openCount++;
    }
    const handOpen = openCount >= 4;
    
    // 检测是否握拳（放宽阈值，扩大1.6倍）
    const threshold = handSize * 0.55 * 1.6; // 从 0.55 放宽到 0.88
    const tips = [8, 12, 16, 20];
    let closedCount = 0;
    tips.forEach(tipIdx => {
      if (getDist(hand[tipIdx], palmCenter) < threshold) {
        closedCount++;
      }
    });
    if (getDist(hand[4], palmCenter) < threshold * 2.4) { // 从 1.5 放宽到 2.4 (1.5 * 1.6)
      closedCount++;
    }
    const handClosed = closedCount >= 5;
    
    if (handOpen) {
      // 手掌张开：向前穿越（优先判断，不改动张开手的逻辑）
      targetTitleWarpSpeed = -0.4;
      titleHandWasOpen = true;
      fistFrameCount = 0; // 张开手时重置握拳缓冲
    } else if (handClosed) {
      // 握拳检测缓冲：需要连续2帧满足条件
      fistFrameCount++;
      if (fistFrameCount >= 2) {
        // 握拳：后退
        targetTitleWarpSpeed = 0.25;
        titleHandWasFist = true;
      } else {
        // 缓冲中，保持当前状态
        targetTitleWarpSpeed = 0;
      }
    } else {
      // 手势不明确时，停止穿越
      targetTitleWarpSpeed = 0;
      fistFrameCount = 0; // 非握拳状态，重置缓冲计数
    }
  } else {
    targetTitleWarpSpeed = 0;
  }
}

function fadeOverlayToBlack(callback){
  const overlay = document.getElementById("fadeOverlay");
  if(!overlay){ if(callback) callback(); return; }
  overlay.style.display = "block";
  requestAnimationFrame(()=>overlay.classList.add("visible"));
  setTimeout(()=>{ if(callback) callback(); }, FADE_DURATION);
}
function fadeOverlayToTransparent(callback){
  const overlay = document.getElementById("fadeOverlay");
  if(!overlay){ if(callback) callback(); return; }
  overlay.classList.remove("visible");
  setTimeout(()=>{ overlay.style.display = "none"; if(callback) callback(); }, FADE_DURATION);
}
// 显示进入 stage1 时的标语序列
function showStage1TipSequence(){
  const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  
  if(!tip || !tipText) {
    // 如果元素不存在，直接完成标语序列
    stage1TipSequenceState = "completed";
    return;
  }
  
  // 清除之前的定时器
  if(stage1TipSequenceTimer) {
    clearTimeout(stage1TipSequenceTimer);
    stage1TipSequenceTimer = null;
  }
  
  // 隐藏新动画，显示tipText
  const clockwork = document.getElementById("mysticClockwork");
  if(clockwork) clockwork.style.display = "none";
  tipText.style.display = "block";
  
  // 获取手部图片元素（提升到函数作用域顶部）
  const hand1Image = document.getElementById("hand1Image");
  const hand2Image = document.getElementById("hand2Image");
  
  // 显示标语1
  stage1TipSequenceState = "showingTip1";
  tipText.innerHTML = "手をゆっくり前へ伸ばしてみてください。<br>星たちが、あなたの指先へと集まってきます。";
  tip.style.display = "flex";
  
  // 同时显示 hand1 和 hand2 图片
  if(hand1Image && hand2Image) {
    // 调试信息
    console.log("=== 手部图片显示调试 ===");
    console.log("hand1Image src:", hand1Image.src);
    console.log("hand2Image src:", hand2Image.src);
    
    hand1Image.style.display = "block";
    hand2Image.style.display = "block";
    // 重置状态，确保淡入动画正常
    hand1Image.classList.remove("visible");
    hand2Image.classList.remove("visible");
    
    // 图片加载监听
    hand1Image.onerror = function() { 
      console.error("❌ hand1.PNG 加载失败！路径:", hand1Image.src);
      console.error("请确认 hand1.PNG 文件是否存在，且与 HTML 文件在同一目录");
    };
    hand2Image.onerror = function() { 
      console.error("❌ hand2.PNG 加载失败！路径:", hand2Image.src);
      console.error("请确认 hand2.PNG 文件是否存在，且与 HTML 文件在同一目录");
    };
    hand1Image.onload = function() { 
      console.log("✅ hand1.PNG 加载成功！尺寸:", hand1Image.naturalWidth, "x", hand1Image.naturalHeight);
    };
    hand2Image.onload = function() { 
      console.log("✅ hand2.PNG 加载成功！尺寸:", hand2Image.naturalWidth, "x", hand2Image.naturalHeight);
    };
    
    // 如果图片已经加载完成，立即触发 onload
    if(hand1Image.complete) hand1Image.onload();
    if(hand2Image.complete) hand2Image.onload();
  } else {
    console.error("❌ 手部图片元素未找到！");
  }
  
  requestAnimationFrame(() => {
    tip.classList.add("visible");
    // 同时显示手部图片
    if(hand1Image && hand2Image) {
      // 强制重排，确保样式生效
      void hand1Image.offsetWidth;
      void hand2Image.offsetWidth;
      hand1Image.classList.add("visible");
      hand2Image.classList.add("visible");
      console.log("✅ 手部图片已添加 visible 类，应该可见了");
    }
    // 4秒后显示标语2（第一句标语显示4秒）
    stage1TipSequenceTimer = setTimeout(() => {
      tip.classList.remove("visible");
      // 同时隐藏手部图片
      if(hand1Image && hand2Image) {
        hand1Image.classList.remove("visible");
        hand2Image.classList.remove("visible");
        // 等待淡出动画完成后隐藏
        setTimeout(() => {
          hand1Image.style.display = "none";
          hand2Image.style.display = "none";
        }, 1500); // 和 TIP_FADE_DURATION 保持一致
      }
      stage1TipSequenceTimer = setTimeout(() => {
        // 显示标语2，同时开始手势识别计时
        stage1TipSequenceState = "showingTip2";
        stage1GestureDetectionStartTime = performance.now(); // 从标语2出现时开始计时
        tipText.innerHTML = "星たちが集まってきたね！<br>指先をそっと動かして、星座の形を作ってみましょう。";
        tip.classList.add("visible");
        // 6秒后隐藏标语2，但继续等待手势识别（如果还没到10秒）
        stage1TipSequenceTimer = setTimeout(() => {
          tip.classList.remove("visible");
          stage1TipSequenceTimer = setTimeout(() => {
            tip.style.display = "none";
            // 如果还没到10秒，继续等待手势识别
            if(stage1TipSequenceState === "showingTip2") {
              stage1TipSequenceState = "waitingGesture";
            }
            stage1TipSequenceTimer = null;
          }, TIP_FADE_DURATION);
        }, STAGE1_TIP_DISPLAY_DURATION);
      }, TIP_FADE_DURATION);
    }, 4000);
  });
}
// 检查手势识别并显示标语3
function checkGestureAndShowTip3(){
  // 从标语2显示时就开始检测（showingTip2 或 waitingGesture 状态）
  if(stage1TipSequenceState !== "waitingGesture" && stage1TipSequenceState !== "showingTip2") {
    return false;
  }
  
  // 如果已经在显示标语3，不再重复执行
  if(stage1TipSequenceState === "showingTip3") {
    return false;
  }
  
  const elapsed = performance.now() - stage1GestureDetectionStartTime;
  if(elapsed >= STAGE1_GESTURE_DETECTION_DURATION) {
    // 清除标语2的定时器，避免冲突
    if(stage1TipSequenceTimer) {
      clearTimeout(stage1TipSequenceTimer);
      stage1TipSequenceTimer = null;
    }
    
    // 10秒后显示标语3
    const tip = document.getElementById("tipOverlay");
    const tipText = document.getElementById("tipText");
    
    if(tip && tipText) {
      // 隐藏新动画，显示tipText
      const clockwork = document.getElementById("mysticClockwork");
      if(clockwork) clockwork.style.display = "none";
      tipText.style.display = "block";
      
      // 立即更新状态，防止重复执行
      stage1TipSequenceState = "showingTip3";
      tipText.innerHTML = "……いい感じですね！<br>それでは、次のステップに進みましょう。<br>これから 10 秒間、好きな形をつくってみてください。";
      tip.style.display = "flex";
      
      // 如果标语2还在显示，先隐藏它
      tip.classList.remove("visible");
      
      requestAnimationFrame(() => {
        tip.classList.add("visible");
        // 6秒后完成标语序列，开始倒计时
        stage1TipSequenceTimer = setTimeout(() => {
          tip.classList.remove("visible");
          stage1TipSequenceTimer = setTimeout(() => {
            tip.style.display = "none";
            stage1TipSequenceState = "completed";
            // 开始倒计时
            if(stage1StartTime === 0) {
              stage1StartTime = performance.now();
            }
            stage1TipSequenceTimer = null;
          }, TIP_FADE_DURATION);
        }, STAGE1_TIP_DISPLAY_DURATION);
      });
    } else {
      stage1TipSequenceState = "completed";
      if(stage1StartTime === 0) {
        stage1StartTime = performance.now();
      }
    }
    return true;
  }
  return false;
}

// 显示 stage1 到 stage1.5 的过渡标语
let stage1To1_5TipTimer = null; // 用于存储定时器，以便清除
function showStage1To1_5Tip(){
  // 清空粒子特效
  disposeParticleCallResources();
  
  // 清除可能正在运行的定时器
  if(stage1To1_5TipTimer){
    clearTimeout(stage1To1_5TipTimer);
    stage1To1_5TipTimer = null;
  }
  
  // 安全定时器：防止过渡流程卡住
  // 整个过渡流程：fadeIn(800ms) + showTip(2000ms) + fadeOut(600ms) + fadeToTransparent(800ms) ≈ 4.2秒
  // 安全定时器设置为 5 秒
  const safetyTimer = setTimeout(() => {
    if(stage === "stage1To1_5") {
      enterStage1_5();
    }
  }, 5000); // 5秒安全超时
  
  fadeOverlayToBlack(() => {
    clearTimeout(safetyTimer);
    
    const tip = document.getElementById("tipOverlay");
    const tipText = document.getElementById("tipText");
    
    if(!tip || !tipText) {
      // 如果元素不存在，直接进入 stage1.5
      enterStage1_5();
      return;
    }
    
    // 清除之前的内容和状态
    tipText.innerHTML = "";
    tip.classList.remove("visible");
    
    // 隐藏新动画，显示tipText
    const clockwork = document.getElementById("mysticClockwork");
    if(clockwork) clockwork.style.display = "none";
    tipText.style.display = "block";
    
    // 设置新内容
    tipText.innerHTML = "本番のドローイングに進む前に、少し練習してみましょう！";
    tip.style.display = "flex";
    
    // 立即淡出黑色遮罩，让标语可见
    setTimeout(() => {
      fadeOverlayToTransparent(() => {
      });
    }, 150);
    
    requestAnimationFrame(() => {
      tip.classList.add("visible");
      // 显示3秒后淡出并进入 stage1.5
      stage1To1_5TipTimer = setTimeout(() => {
        tip.classList.remove("visible");
        stage1To1_5TipTimer = setTimeout(() => {
          tip.style.display = "none";
          tipText.innerHTML = ""; // 清除内容
          enterStage1_5();
          stage1To1_5TipTimer = null;
        }, TIP_FADE_DURATION);
      }, 3000); // 显示3秒
    });
  });
}

// 停止 Pen 动画循环
function stopPenAnimation() {
  if(penAnimationTimer) {
    clearTimeout(penAnimationTimer);
    penAnimationTimer = null;
  }
  
  const penImg = document.getElementById("penAnimation");
  if(penImg) {
    penImg.classList.remove("visible");
    
    // 清除旧的隐藏定时器
    if(penHideTimer) clearTimeout(penHideTimer);
    
    // 设置新的隐藏定时器
    penHideTimer = setTimeout(() => {
      penImg.style.display = "none";
      penHideTimer = null;
    }, 300);
  }
}

// 更新 Stage1.5 标语显示
// 【优化后的标语更新函数】支持淡出→换字→淡入的平滑过渡
function updateStage1_5Tip(message) {
  const now = performance.now();
   const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  
  if(!tip || !tipText) return;
  
  // 如果内容相同，不需要更新
  if(tipText.innerHTML === message) return;
  
  // 清除之前的定时器，避免动画冲突
  if(stage1_5TipUpdateTimer) {
    clearTimeout(stage1_5TipUpdateTimer);
    stage1_5TipUpdateTimer = null;
  }
  
  // 【4】优化过渡动画：淡出(400ms) → 换字 → 淡入(400ms)
  const FADE_OUT_DURATION = 400;
  const FADE_IN_DURATION = 400;
  
  // 如果当前标语是可见的，先淡出
  if(tip.classList.contains("visible")) {
    tip.classList.remove("visible");
    
    // 等待淡出完成后再换字并淡入
    stage1_5TipUpdateTimer = setTimeout(() => {
      // 换字
      tipText.innerHTML = message;
      
      // 确保元素存在
      tip.style.display = "flex";
      
      // 强制重排，确保样式生效
      void tip.offsetWidth;
      
      // 淡入
      tip.classList.add("visible");
      
      // 更新最后更新时间
      stage1_5TipLastUpdate = performance.now();
      
      stage1_5TipUpdateTimer = null;
    }, FADE_OUT_DURATION);
  } else {
    // 如果当前标语不可见，直接设置内容并淡入
    tipText.innerHTML = message;
    tip.style.display = "flex";
    
    // 强制重排
    void tip.offsetWidth;
    
    // 淡入
    tip.classList.add("visible");
    
    // 更新最后更新时间
    stage1_5TipLastUpdate = performance.now();
  }
}

// 显示标语函数（居中显示）
function showTip(message) {
  const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  
  if(!tip || !tipText) return;
  
  // 设置标语内容
  tipText.innerHTML = message;
  
  // 确保元素可见
  tip.style.display = "flex";
  
  // 重置对齐方式为居中（避免被顶部对齐影响）
  tip.style.alignItems = "center";
  tipText.style.marginTop = "7vmin"; // 恢复默认的margin-top
  
  // 强制重排，确保样式生效
  void tip.offsetWidth;
  
  // 淡入显示
  tip.classList.add("visible");
}

// 在画面上方显示标语函数（专门用于进度条标语）
function showTipTop(message) {
  const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  
  if(!tip || !tipText) return;
  
  // 设置标语内容
  tipText.innerHTML = message;
  
  // 确保元素可见
  tip.style.display = "flex";
  
  // 临时修改对齐方式为顶部对齐
  tip.style.alignItems = "flex-start";
  tipText.style.marginTop = "8vmin"; // 距离顶部80px
  
  // 强制重排，确保样式生效
  void tip.offsetWidth;
  
  // 淡入显示
  tip.classList.add("visible");
}

// 【2】状态进入函数：每个状态只在"进入状态时"切换标语一次
function enterStage1_5State(newState) {
  const tipMessages = {
    "waitingPinch": "親指と人差し指を軽くくっつけると、あなたの指先は 「星空のペン」 になります。",
    "drawing": "そのまま指先を動かすと、星の軌跡が描かれます。",
    "waitingRelease": "指を離してみよう！線が止まります。",
    "complete": "星空で線を描けましたね！！",
    "progressBar": "人差し指と親指で下の円をつまみ、そのまま長押しして、次のステージに入りましょう！"
  };
  
  const message = tipMessages[newState];
  if(message) {
    updateStage1_5Tip(message);
  }
}

// 显示 stage2 到 stage3 的过渡标语
let stage2To3TipTimer = null; // 用于存储定时器，以便清除

// Create stars for the Mystic Astral Clockwork animation
function createStars(layer, count, radius, size, delay, opacity) {
  const container = document.getElementById(layer);
  if (!container) return;
  
  for (let i = 0; i < count; i++) {
    const star = document.createElement('div');
    star.className = 'star-p';
    
    const angle = (360 / count) * i;
    const rad = (angle * Math.PI) / 180;
    const x = Math.cos(rad) * radius;
    const y = Math.sin(rad) * radius;
    
    star.style.width = size + 'vmin';
    star.style.height = size + 'vmin';
    star.style.setProperty('--target-transform', `translate(calc(-50% + ${x}vmin), calc(-50% + ${y}vmin))`);
    star.style.setProperty('--target-opacity', opacity);
    star.style.animationDelay = (delay + i * 0.05) + 's';
    
    container.appendChild(star);
  }
}

// Initialize all star layers
function initStars() {
  createStars('layer1', 8, 20, 0.4, 0.6, 0.8);
  createStars('layer2', 12, 15, 0.3, 0.8, 0.7);
  createStars('layer3', 16, 10, 0.2, 1.0, 0.6);
}

function showStage2To3Tip(){
  // 清除可能正在运行的定时器
  if(stage2To3TipTimer){
    clearTimeout(stage2To3TipTimer);
    stage2To3TipTimer = null;
  }
  
  fadeOverlayToBlack(() => {
    const tipOverlay = document.getElementById("tipOverlay");
    const clockwork = document.getElementById("mysticClockwork");
    const tipText = document.getElementById("tipText");
    
    if(!tipOverlay || !clockwork) return;

    // 播放Stage3完成标语BGM（叠加在Stage2 BGM上，音量正常）
    const stage3BGM = document.getElementById("stage3BGM");
    if (stage3BGM) {
      stage3BGM.currentTime = 0;
      stage3BGM.volume = 1.0; // 正常音量
      stage3BGM.play().catch(e => console.log("Stage3 BGM播放失败:", e));
    }

    // Hide old tipText and show new animation
    if(tipText) tipText.style.display = "none";
    clockwork.style.display = "flex";
    tipOverlay.style.display = "flex";
    
    // Reset SVG animation for replay
    const svg = clockwork.querySelector('.s1-ring-svg');
    if(svg) {
      const newSvg = svg.cloneNode(true);
      svg.parentNode.replaceChild(newSvg, svg);
    }
    
    // Reset stars
    const stars = document.querySelectorAll('.star-p');
    stars.forEach(s => s.style.animationName = 'none');

    requestAnimationFrame(() => {
      tipOverlay.classList.add("visible");
      
      // Trigger animation
      setTimeout(() => {
        clockwork.classList.add("active");
        stars.forEach(s => s.style.animationName = 'star-fade-in');
      }, 100);

      // Hide after 3 seconds
      stage2To3TipTimer = setTimeout(() => {
        tipOverlay.classList.remove("visible");
        stage2To3TipTimer = setTimeout(() => {
          tipOverlay.style.display = "none";
          clockwork.classList.remove("active"); // Reset state
          clockwork.style.display = "none"; // Hide animation
          if(tipText) tipText.style.display = "block"; // Restore tipText for other functions
          fadeOverlayToTransparent();
          stage2To3TipTimer = null;
        }, 600); // Wait for fade out
      }, 3000);
    });
    setTimeout(() => fadeOverlayToTransparent(), 150);
  });
}

// 显示 stage1.5 到 stage2 的过渡标语
let stage1_5To2TipTimer = null; // 用于存储定时器，以便清除
function showStage1_5To2Tip(){
  // 清除可能正在运行的定时器
  if(stage1_5To2TipTimer){
    clearTimeout(stage1_5To2TipTimer);
    stage1_5To2TipTimer = null;
  }
  
  // 确保隐藏2hand图片（如果正在显示）
  const twoHandImage = document.getElementById("twoHandImage");
  if(twoHandImage) {
    twoHandImage.classList.remove("visible");
    setTimeout(() => {
      twoHandImage.style.display = "none";
    }, 1500);
  }
  
  // 设置过渡状态，保持stage1的手势识别功能继续运行
  stage = "stage1_5To2";
  
  // 隐藏提示和进度条
  const progressHint = document.getElementById("stage1_5ProgressHint");
  const progressBar = document.getElementById("stage1_5ProgressBar");
  if(progressHint) {
    progressHint.classList.remove("visible");
    setTimeout(() => {
      progressHint.style.display = "none";
    }, 600);
  }
  if(progressBar) {
    progressBar.classList.remove("visible");
    setTimeout(() => {
      progressBar.style.display = "none";
    }, 600);
    // 重置进度条 UI
    const line = document.getElementById("p09-line");
    if(line) line.style.width = "0%";
    const dots = document.querySelectorAll(".p09-dot");
    dots.forEach(d => d.classList.remove("active"));
    const targetZone = document.getElementById("p09-target");
    if(targetZone) targetZone.classList.remove("active");
  }
  
  // 直接进入 stage2，标语将在 stage2 开始时显示
  fadeOverlayToBlack(() => {
    fadeOverlayToTransparent(() => {
      enterStage2FromStage1_5();
    });
  });
}

// 从 stage1.5 进入 stage2（标语显示完成后调用）
function enterStage2FromStage1_5(){
  // 【新增】重置标语样式，清除 Stage 1.5 的顶部对齐设置，恢复居中
  const tipOverlay = document.getElementById("tipOverlay");
  const tipTextElem = document.getElementById("tipText");
  
  if (tipOverlay && tipTextElem) {
    // 清空行内样式，使其恢复 CSS 文件中定义的默认值 (align-items: center)
    tipOverlay.style.alignItems = ""; 
    tipTextElem.style.marginTop = ""; 
  }
  
  // 【立即切换背景】在显示第一句标语之前，立即切换到 Stage 2 的星空背景（但不显示星座）
  setupStage2BackgroundOnly();
  
  // 先显示两句标语，然后再完成 stage2 的初始化
  const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  
  if(!tip || !tipText) {
    // 如果元素不存在，直接初始化 stage2
    initializeStage2();
    return;
  }
  
  // 清除之前的内容和状态
  tipText.innerHTML = "";
  tip.classList.remove("visible");
  
  // 隐藏新动画，显示tipText
  const clockwork = document.getElementById("mysticClockwork");
  if(clockwork) clockwork.style.display = "none";
  tipText.style.display = "block";
  
  // 设置第一句标语内容
  tipText.innerHTML = "それでは、本番へ！<br>想像力を自由に広げて、あなたの星座が語る物語を絵で描き出してみましょう。";
  tip.style.display = "flex";
  requestAnimationFrame(() => {
    tip.classList.add("visible");
    // 第一句标语显示2秒后淡出
    stage1_5To2TipTimer = setTimeout(() => {
      tip.classList.remove("visible");
      stage1_5To2TipTimer = setTimeout(() => {
        tip.style.display = "none";
        tipText.innerHTML = ""; // 清除内容
        // 标语显示完成后，才真正初始化stage2（此时才绘制星座）
        initializeStage2();
        stage1_5To2TipTimer = null;
      }, TIP_FADE_DURATION); // 等待第一句标语淡出完成
    }, 3000); // 第一句标语显示2秒
  });
}

// 只设置 Stage2 的背景（不绘制星座）- 在显示标语之前立即调用
function setupStage2BackgroundOnly(){
  // 设置过渡状态（用于标识当前处于过渡阶段）
  stage = "stage1_5To2";
  
  // 隐藏视频背景
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.remove("stage1Visible");
  }
  
  // 设置 Stage2 的相机位置为标题界面的初始位置（与标题界面完全一致）
  const tiltAngle = 6 * (Math.PI / 180);
  const initialZ = 24;
  const y = (initialZ - initialZ) * Math.tan(tiltAngle); // y = 0
  camera.position.set(0, y, initialZ);
  // 同步设置目标位置，确保相机位置稳定
  camTargetX = 0;
  camTargetY = y;
  camTargetZ = initialZ;
  
  // Stage2 一开始就准备 3D 影子星座（但不绘制到画布）
  prepareShadowConstellationForStage2();
  
  // 显示画布（提前显示，确保背景可见）
  artCanvas.style.display = "block";
  uiCanvas.style.display = "block";
  
  // 清除画布（但不绘制星座，星座将在 initializeStage2() 中绘制）
  artCtx.clearRect(0, 0, W, H);
  uiCtx.clearRect(0, 0, W, H);
  // 【关键】不绘制星座，让背景先显示
  artCanvasDirty = false;
  
  // 重置绘画状态
  strokePolylines = [];
  currentStrokePath = null;
  penHist = [];
  lastPen = null;
  pinching = false;
  inkCtx.clearRect(0, 0, W, H);
  
  // 停止标题BGM（如果还在播放）
  const titleBGM = document.getElementById("titleBGM");
  if (titleBGM) {
    titleBGM.pause();
    titleBGM.currentTime = 0;
  }
  
  // 停止introBGM（stage1-1.mp3，在stage1.5结束时停止）
  const introBGM = document.getElementById("introBGM");
  if (introBGM) {
    introBGM.pause();
    introBGM.currentTime = 0;
  }
  
  // 播放Stage2 BGM（在标语显示时就开始播放）
  const stage2BGM = document.getElementById("stage2BGM");
  if (stage2BGM) {
    stage2BGM.currentTime = 0;
    stage2BGM.volume = 0.7; // 音量70%
    stage2BGM.play().catch(e => console.log("Stage2 BGM播放失败:", e));
  }
  
  // 【关键】立即调用一次 updateTitleBackground() 确保背景立即渲染
  // 注意：updateTitleBackground() 已经支持 stage === "stage1_5To2" 状态，会显示星空背景
  updateTitleBackground();
}


// Stage2 的初始化逻辑（从 enterStage2FromStage1_5 中分离出来）
function initializeStage2(){
  // 进入 stage2，完成剩余的初始化
  stage = 2;
  updateActivityTime(); // 进入 stage 时更新活动时间
  
  // 【延迟显示星座】在标语播放完毕后，才开始绘制星座
  artCtx.clearRect(0, 0, W, H);
  if(savedPolygonGlobal) {
    drawStage1Polyline(savedPolygonGlobal, artCtx, savedConstellationEdges);
  }
  artCanvasDirty = false;
  
  // 显示工具覆盖层
  setToolOverlayVisible(true);
  
  // 完成 stage2 的初始化（显示提示等）
  finishStage2Initialization();
}

// 完成 stage2 的初始化（显示提示等）
function finishStage2Initialization(){
  // 显示 Stage2 提示
  const stage2Hint = document.getElementById("stage2Hint");
  if(stage2Hint) {
    stage2Hint.style.display = "block";
    requestAnimationFrame(() => {
      stage2Hint.classList.add("visible");
    });
  }
  const stage2TopHint = document.getElementById("stage2TopHint");
  if(stage2TopHint) {
    stage2TopHint.style.display = "block";
    requestAnimationFrame(() => {
      stage2TopHint.classList.add("visible");
    });
  }
  
  // 显示绘画控制小标语（stage2中一直显示）
  const drawingControlHint = document.getElementById("drawingControlHint");
  if(drawingControlHint) {
    // 设置stage2专用标语
    drawingControlHint.textContent = "親指と人差し指くっつけると→ 線が出る/筆と消しゴムの切り替え　親指と人差し指離すと → 線が止まる";
    drawingControlHint.style.display = "block";
    requestAnimationFrame(() => {
      drawingControlHint.classList.add("visible");
    });
  }
  
  // 显示2hand.PNG动图在顶部
  const twoHandImage = document.getElementById("twoHandImage");
  if (twoHandImage) {
    twoHandImage.style.display = "block";
    requestAnimationFrame(() => {
      twoHandImage.classList.add("visible");
    });
  }
  
  updateActivityTime();
}


// 在过渡状态时保持 stage1 的背景显示
function doStage1To1_5Transition(){
  // UI 层清除
  uiCtx.clearRect(0,0,W,H);
  // 艺术层：显示保存的星座形状（静态背景）
  artCtx.clearRect(0,0,W,H);
  
  // 保持视频背景显示
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.add("stage1Visible");
  }
  
  // 显示保存的星座形状（背景）- 绘制到艺术层
  if(savedPolygonGlobal) {
    drawStage1Polyline(savedPolygonGlobal, artCtx, savedConstellationEdges);
  }
  
  // 不执行任何手部检测或更新逻辑，只是保持背景显示
}

// 在 stage1.5 到 stage2 的过渡状态时，只保持背景显示，不执行手势识别
function doStage1_5To2Transition(){
  // UI 层清除
  uiCtx.clearRect(0,0,W,H);
  
  // 艺术层：在过渡期间不绘制星座，只保持星空背景显示
  // 注意：不显示视频背景，因为 Stage 2 不需要视频背景
  // 星空背景由 updateTitleBackground() 在主循环中持续渲染
  // 星座将在 initializeStage2() 中才绘制，这里不绘制
  
  // 不执行任何手部检测或更新逻辑，只是保持背景显示
}

// 进入 stage1.5
function enterStage1_5(){
  stage = 1.5;
  // 重置 stage1 手势识别状态，防止在 stage1.5 中重复触发
  stage1TipSequenceState = "completed";
  stage1GestureDetectionStartTime = 0;
  // 保持视频背景显示（和 stage1 一样）
  // 初始化 Stage1.5 状态
  stage1_5State = "waitingPinch";
  stage1_5LineDrawn = false;
  stage1_5StateChangeTime = performance.now();
  // 清空绘画数据
  strokePolylines = [];
  currentStrokePath = null;
  penHist = [];
  lastPen = null;
  pinching = false;
  inkCtx.clearRect(0, 0, W, H);
  // 重置手势检测状态（使用与 Stage 2 相同的检测逻辑）
  stage1_5LastPos = null;
  stage1_5LastTime = null;
  // 设置脏标记，让艺术层在下一帧显示星座背景
  artCanvasDirty = true;
  updateActivityTime();
  
  // === 关键修复开始 ===
  
  // 1. 记录进入时间（用于防误触）
  stage1_5EntryTime = performance.now();

  // 2. 彻底清理所有定时器（拆弹！）
  if(penAnimationTimer) { clearTimeout(penAnimationTimer); penAnimationTimer = null; }
  if(penHideTimer) { clearTimeout(penHideTimer); penHideTimer = null; }
  
  // 3. 准备元素
  const targetTip = "親指と人差し指を軽くくっつけると、あなたの指先は 「星空のペン」 になります。";
  const tip = document.getElementById("tipOverlay");
  const tipText = document.getElementById("tipText");
  const penImg = document.getElementById("penAnimation");
  
  // 4. 强制同步启动
  if(tip && tipText && penImg) {
    tipText.innerHTML = targetTip;
    
    // 强制显示（覆盖任何 display:none）
    tip.style.display = "flex";
    penImg.style.display = "block";
    
    // 重置状态
    tip.classList.remove("visible");
    penImg.classList.remove("visible");
    
    // 清除标语更新定时器，避免冲突
    if(stage1_5TipUpdateTimer) {
      clearTimeout(stage1_5TipUpdateTimer);
      stage1_5TipUpdateTimer = null;
    }
    
    // 强制重绘
    void tip.offsetWidth; 
    
    // 触发淡入
    tip.classList.add("visible");
    penImg.classList.add("visible");
    
    // 更新标语最后更新时间（初始化时不受 cooldown 限制）
    stage1_5TipLastUpdate = performance.now();
    
    // === 动图参数配置 ===
    const GIF_DURATION = 857;  // 动图时长
    const REST_TIME = 1000;     // 休息时长

    // 启动循环
    function playCycle() {
      // 1. 确保它是可见的
      penImg.classList.add("visible");
      
      // 2. 重置图片源，强制从头播放
      // (这是为了让 GIF 重新开始动)
      const src = penImg.src;
      penImg.src = "";
      penImg.src = src;
      
      // 3. 设置定时器：等待 (播放时长 + 休息时长) 后，进行下一次循环
      // 注意：这里不再隐藏图片，图片会一直停留在屏幕上
      // 如果 GIF 是"只播放一次"的格式，它会自动停在最后一帧，达成"休息"的视觉效果
      penAnimationTimer = setTimeout(() => {
        playCycle(); 
      }, GIF_DURATION + REST_TIME);
    }
    
    // 立即开始
    playCycle();
  }
}
let lockedFingerStars = null;

async function generateConstellationQR(rec) {
  // 1. 准备数据
  const flatten = (points) => {
    if (!points) return [];
    const flat = [];
    let prevX = 0, prevY = 0;
    const tolerance = 3;
    points.forEach((pt, index) => {
      const x = Math.round(pt.x);
      const y = Math.round(pt.y);
      if (index === 0 || index === points.length - 1) {
        flat.push(x, y);
        prevX = x; prevY = y;
      } else {
        const dist = Math.hypot(x - prevX, y - prevY);
        if (dist > tolerance) {
          flat.push(x, y);
          prevX = x; prevY = y;
        }
      }
    });
    return flat;
  };

  // === 修改重点在这里 ===
  const exportData = {
    p: flatten(rec.poly),
    s: (rec.strokePolylines || []).map(path => flatten(path)),
    // 新增 e (edges)：把 [{i:0, j:1}, {i:2, j:3}] 压缩成 [0,1, 2,3]
    e: (rec.edges || []).flatMap(edge => [edge.i, edge.j]),
    d: new Date().toLocaleDateString('ja-JP'),
    ts: Date.now()
  };

  // ---------------------------------------------------------
  // 【重要】请在这里填入你刚才在 JSONBin 申请的 Master Key
  const API_KEY = '$2a$10$H56XRVSRijO/AVt8OmmhKeRKR4gYZqqxtyeYFd0dpvTKy2UQdhIma'; 
  // ---------------------------------------------------------

  // 显示 "上传中..." 的提示
  let qrContainer = document.getElementById("qrOverlay");
  if (qrContainer) qrContainer.remove();
  
  // 创建简单的加载提示
  const loadingDiv = document.createElement("div");
  loadingDiv.id = "uploadLoading";
  loadingDiv.style.cssText = "position:fixed; bottom:5vmin; right:5vmin; color:white; background:rgba(0,0,0,0.8); padding:1vmin 2vmin; border-radius:0.8vmin; z-index:200;";
  loadingDiv.innerText = "星を空へ送っています... (Uploading...)";
  document.body.appendChild(loadingDiv);

  try {
    // 2. 上传数据到 JSONBin
    const response = await fetch('https://api.jsonbin.io/v3/b', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Master-Key': API_KEY,
        'X-Bin-Private': 'false' // 设置为 false，方便 viewer 读取
      },
      body: JSON.stringify(exportData)
    });

    if (!response.ok) throw new Error("Upload failed");

    const result = await response.json();
    const binId = result.metadata.id; // 拿到唯一的 ID

    // 3. 生成包含 ID 的短链接
    // 【记得改成你的 GitHub Pages 地址】
    const baseURL = "https://han7191909-byte.github.io/star-project/viewer.html";
    const fullURL = `${baseURL}?id=${binId}`; // 注意这里变成了 ?id=...

    console.log("云端 ID:", binId);
    console.log("最终链接:", fullURL);

    // 移除加载提示
    loadingDiv.remove();

    // 4. 显示二维码 (UI代码)
    qrContainer = document.createElement("div");
    qrContainer.id = "qrOverlay";
    qrContainer.className = "transparent";
    qrContainer.style.cssText = `
      position: fixed; bottom: 3vmin; right: 3vmin; 
      padding: 2.4vmin; border-radius: 1.6vmin; z-index: 100;
      display: flex; flex-direction: column; align-items: center; gap: 1.2vmin;
      opacity: 0; transform: translateY(2vmin); transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
      pointer-events: auto;
      background: rgba(10, 14, 28, 0.05) !important;
      backdrop-filter: blur(0.4vmin) !important;
      -webkit-backdrop-filter: blur(0.4vmin) !important;
    `;
    
    const qrDiv = document.createElement("div");
    qrDiv.style.cssText = "background: rgba(255, 255, 255, 0.85); padding: 0.8vmin; border-radius: 0.8vmin;";
    const label = document.createElement("div");
    label.innerHTML = "あなたの星を持ち帰る<br><span style='font-size:1vmin; opacity:0.7; display:block; margin-top:0.4vmin;'>Take your star home</span>";
    label.style.cssText = "color: #eaf6ff; font-size: 1.4vmin; font-family: 'Kan410TyposStd', sans-serif; text-align: center; letter-spacing: 0.1vmin; line-height: 1.4;";
    
    const closeBtn = document.createElement("div");
    closeBtn.className = "qr-close-btn";
    closeBtn.innerHTML = "×";
    closeBtn.style.cssText = "position:absolute; top:0.8vmin; right:1.2vmin; color:rgba(255,255,255,0.5); cursor:pointer; font-size:1.8vmin;";
    
    // 用于存储自动隐藏定时器，以便手动关闭时清除
    let autoHideTimer = null;
    const hideQR = () => {
      if (autoHideTimer) {
        clearTimeout(autoHideTimer);
        autoHideTimer = null;
      }
      qrContainer.style.opacity = "0";
      setTimeout(() => qrContainer.remove(), 800);
    };
    
    closeBtn.onclick = hideQR;

    qrContainer.appendChild(closeBtn);
    qrContainer.appendChild(qrDiv);
    qrContainer.appendChild(label);
    document.getElementById("threeContainer").appendChild(qrContainer);


    // 二维码现在非常简单，Scan 极快！
    new QRCode(qrDiv, {
      text: fullURL,
      width: 160,
      height: 160,
      colorDark : "#000000",
      colorLight : "#ffffff",
      correctLevel : QRCode.CorrectLevel.M 
    });

    requestAnimationFrame(() => {
      qrContainer.style.opacity = "1";
      qrContainer.style.transform = "translateY(0)";
      
      // 15秒后自动隐藏二维码
      autoHideTimer = setTimeout(() => {
        hideQR();
      }, 15000);
    });

  } catch (err) {
    console.error(err);
    loadingDiv.innerText = "Error: 保存失敗";
    setTimeout(() => loadingDiv.remove(), 3000);
  }
}

function enterStage3FromStage2(){
  if(stage === 3) return;
  
  // 不停止Stage2 BGM，让它继续播放
  
  // 隐藏2hand.PNG动图（离开Stage2时）
  const twoHandImage = document.getElementById("twoHandImage");
  if(twoHandImage) {
    twoHandImage.style.display = "none";
    twoHandImage.classList.remove("visible");
  }
  
  stage = 3;
  stage2Warping = false;
  resetStage2PushDetection();
  updateActivityTime();
  RIGHT_BOUNDARY.isAtBoundary = false;
  RIGHT_BOUNDARY.hasShownHint = false;
  RIGHT_BOUNDARY.canReturn = false;
  RIGHT_BOUNDARY.isBouncing = false;
  
  // 重置 Stage2 推开检测状态
  stage2PushInitialDist = null;
  stage2PushMinDist = null;
  stage2PushDetectionStartTime = 0;

  // 1. 生成缩略图和数据记录 (保持不变)
  const thumb = captureThumbnail(640, 400);
  const rec = {
    id: Date.now(),
    date: new Date(),
    dateStr: new Date().toLocaleString(),
    thumb,
    poly: savedPolygonGlobal ? savedPolygonGlobal.map(p=>({...p})) : [],
    // === 新增这一行：保存连线结构 ===
    edges: savedConstellationEdges ? [...savedConstellationEdges] : [],
    strokePolylines: cloneStrokePolylines()
  };
  creations.push(rec);

  // 2. 处理 3D 星座对象 (保持不变)
  if(shadowConstellation){
    shadowConstellation.userData.isUserCreation = true;
    shadowConstellation.userData.creationId = rec.id;

    // 添加笔触线条
    const strokeSets = normalizeStrokePolylines(rec.strokePolylines || []);
    if(strokeSets.length){
      const strokeGroup = new THREE.Group();
      for(let path of strokeSets){
        if(path.length < 2) continue;
        const positions = [];
        for(let p of path){
          positions.push(
            (p.x - W/2) * 0.6,
            -(p.y - H/2) * 0.6,
            -20
          );
        }
        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
        const mat = new THREE.LineBasicMaterial({
          color: 0xffe6cc,
          transparent: true,
          opacity: 0.95,
          blending: THREE.AdditiveBlending
        });
        const line = new THREE.Line(geom, mat);
        line.position.z = 0;
        strokeGroup.add(line);
      }
      if(strokeGroup.children.length){
        shadowConstellation.add(strokeGroup);
        shadowConstellation.userData.strokeLine = strokeGroup;
      }
    }
    
    // 【关键修复点 A】确保星座在正确的位置
    // 之前 Warp 可能会改变它的 Z，这里把它强制固定在画廊的标准显示深度 (-1800)
    shadowConstellation.position.set(0, 0, -1800);
    shadowConstellation.scale.set(1, 1, 1);
    shadowConstellation.rotation.set(0, 0, 0); // 重置旋转

    shadowConstellation.userData.isShadowConstellationFinished = true;
    shadowConstellation.visible = true;
    if(!scene.children.includes(shadowConstellation)){
      scene.add(shadowConstellation);
    }
    rec.group = shadowConstellation;
    shadowConstellation = null;
  } else {
    addCreationToScene(rec);
  }

  // 3. 布局其他旧作品 (保持不变)
  for(let c of creations){
    if(!c.group) addCreationToScene(c);
  }
  layoutCreationsInScene(); // 这会将最新作品(rec)放在 -1800，旧作品随机分布

  addGalleryTile(rec);
  saveCreationsToStorage();

 // 4. 清理 UI
 artCanvas.style.display = "none";
  uiCanvas.style.display = "none";
  inkCtx.clearRect(0,0,W,H);
  document.getElementById("goStage3Btn").style.display = "none";
  document.getElementById("galleryBtn").style.display = "none";
  strokePolylines = [];
  currentStrokePath = null;
  
  // --- 计算 Stage 3 的目标位置 ---
  // 最新创作的星座位置在 (0, 0, -1800)，相机应该对准它
  const CONSTELLATION_Z = -1800; // 最新星座的Z位置
  const titleInitialZ = 24; 
  const tiltAngle = 6 * (Math.PI / 180);
  const y = (titleInitialZ - CONSTELLATION_Z) * Math.tan(tiltAngle);
  
  // 只设置"目标"位置，让 updateCamera 函数里的 Lerp 动画帮你"滑"过去
  // 相机对准最新创作的星座（位置在 0, 0, -1800）
  camTargetX = 0;
  camTargetY = y;
  camTargetZ = titleInitialZ;
  
  // 显示完成标语
  showStage2To3Tip();
  
  // 确保背景星云可见（复用标题界面的同一颗背景球）
  if(titleNebulaBackground) {
    titleNebulaBackground.visible = true;
  }

  // 显示 Stage3 控制提示标语
  const drawingControlHint = document.getElementById("drawingControlHint");
  if(drawingControlHint) {
    // 设置stage3专用标语
    drawingControlHint.textContent = "片手で左右にスワイプ、両手で拡大・縮小　　30秒ほど手の動きが確認できないと、タイトル画面に自動で戻ります。";
    drawingControlHint.style.display = "block";
    setTimeout(() => {
      drawingControlHint.classList.add("visible");
    }, 500);
  }

  // === 新增：生成二维码 ===
  // 获取刚刚创建的最新作品 (数组的最后一个)
  if(creations.length > 0){
    const latestRec = creations[creations.length - 1];
    // 延迟一点点显示，让用户先看标语
    setTimeout(() => {
        generateConstellationQR(latestRec);
    }, 2000); 
  }
}
function enterStage3FromTitle(){
  if(stage === 3) return;
  
  // 停止标题BGM（如果还在播放）
  const titleBGM = document.getElementById("titleBGM");
  if (titleBGM) {
    titleBGM.pause();
    titleBGM.currentTime = 0;
  }
  
  // 隐藏2hand.PNG动图（离开Stage2时）
  const twoHandImage = document.getElementById("twoHandImage");
  if(twoHandImage) {
    twoHandImage.style.display = "none";
    twoHandImage.classList.remove("visible");
  }
  
  stage = 3;
  updateActivityTime();
  RIGHT_BOUNDARY.isAtBoundary = false;
  RIGHT_BOUNDARY.hasShownHint = false;
  RIGHT_BOUNDARY.canReturn = false;
  RIGHT_BOUNDARY.isBouncing = false;
  
  document.getElementById("titleOverlay").style.display = "none";
  document.getElementById("galleryBtn").style.display = "none";
  artCanvas.style.display = "none";
  uiCanvas.style.display = "none";
  
  // 确保背景星云可见（复用标题界面的同一颗背景球）
  if(titleNebulaBackground) {
    titleNebulaBackground.visible = true;
  }
  
    // [修复] 生成并展示画廊
    // 1. 遍历所有作品，如果还没有生成 3D 组 (group)，则立即生成并加入场景
  for(let c of creations){
    if(!c.group) addCreationToScene(c);
  }

  // 2. 将它们在 3D 空间中排布好
  layoutCreationsInScene();
  // 设置 Stage3 的初始相机位置（比标题界面向前推进 500）
  // 标题界面初始位置是 z = 24，所以 Stage3 初始位置是 z = 24 - 500 = -476
  const tiltAngle = 6 * (Math.PI / 180);
  const titleInitialZ = 24;
  const stage3InitialZ = titleInitialZ ; // -476
  const y = (titleInitialZ - stage3InitialZ) * Math.tan(tiltAngle);
  camera.position.set(0, y, stage3InitialZ);
  camTargetX = 0;
  camTargetY = y;
  camTargetZ = stage3InitialZ;
  
  // 显示 Stage3 控制提示标语
  const drawingControlHint = document.getElementById("drawingControlHint");
  if(drawingControlHint) {
    // 设置stage3专用标语
    drawingControlHint.textContent = "片手で左右にスワイプ、両手で拡大・縮小　　30秒ほど手の動きが確認できないと、タイトル画面に自動で戻ります。";
    drawingControlHint.style.display = "block";
    setTimeout(() => {
      drawingControlHint.classList.add("visible");
    }, 500);
  }
}
document.getElementById("goStage3Btn").onclick = ()=>{ 
  updateActivityTime(); // 点击按钮时更新活动时间
  enterStage3FromStage2(); 
};

//   阶段跳转功能
function jumpToStage(targetStage){
  if(stage === targetStage) return;
  
  updateActivityTime(); // 跳转 stage 时更新活动时间
  
  // 如果跳转到标题界面，使用完整的重置函数
  if(targetStage === 0){
    enterStage0(true);
    return;
  }
  
  // 隐藏标题界面
  document.getElementById("titleOverlay").style.display = "none";
  
  // 隐藏提示文字（按键进入时不应显示）
  const instructionText = document.getElementById("instructionText");
  if(instructionText) {
    instructionText.style.display = "none";
  }
  
  // 隐藏视频背景（如果之前显示）
  const videoElement = document.getElementById("videoElement");
  if(videoElement) {
    videoElement.classList.remove("stage1Visible");
  }
  
  // 重置相机位置
  camera.position.set(0, 0, 1200);
  camTargetX = 0;
  camTargetY = 0;
  camTargetZ = 1200;
  
  if(targetStage === 1){
    // 跳转到 Stage 1：使用与正常进入相同的流程
    enterStage1FromTitle();
  } else if(targetStage === 1.5){
    // 跳转到 Stage 1.5：需要先创建一个默认的多边形，然后直接进入 stage1.5
    const centerX = W / 2;
    const centerY = H / 2;
    const radius = 150;
    const defaultPolygon = [];
    // 左手4个点（左侧）
    for(let i = 0; i < 4; i++){
      const angle = Math.PI * (0.5 + i * 0.3);
      defaultPolygon.push({
        x: centerX - radius * 1.5 + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
    }
    // 右手4个点（右侧）
    for(let i = 0; i < 4; i++){
      const angle = Math.PI * (0.5 + i * 0.3);
      defaultPolygon.push({
        x: centerX + radius * 1.5 + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
    }
    // 标准化星座形状
    savedPolygonGlobal = normalizeConstellation(defaultPolygon);
    
    // 直接进入 stage1.5
    enterStage1_5();
  } else if(targetStage === 2){
    // 跳转到 Stage 2：先显示两句标语，然后再进入 Stage 2
    // 创建一个简单的默认星座形状（8个点，形成两个手的位置）
    const centerX = W / 2;
    const centerY = H / 2;
    const radius = 150;
    const defaultPolygon = [];
    // 左手4个点（左侧）
    for(let i = 0; i < 4; i++){
      const angle = Math.PI * (0.5 + i * 0.3);
      defaultPolygon.push({
        x: centerX - radius * 1.5 + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
    }
    // 右手4个点（右侧）
    for(let i = 0; i < 4; i++){
      const angle = Math.PI * (0.5 + i * 0.3);
      defaultPolygon.push({
        x: centerX + radius * 1.5 + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
    }
    
    // 标准化星座形状
    savedPolygonGlobal = normalizeConstellation(defaultPolygon);
    
    // 计算并保存星座连线结构
    savedConstellationEdges = computeConstellationEdges(defaultPolygon);
    
    // 隐藏标题界面的提示文字
    const instructionText = document.getElementById("instructionText");
    if(instructionText) {
      instructionText.style.display = "none";
    }
    
    // 调用显示两句标语的函数，标语显示时会自动切换到 Stage 2 背景
    enterStage2FromStage1_5();
  } else if(targetStage === 3){
    // 跳转到 Stage 3：直接进入画廊
    enterStage3FromTitle();
  }
}

// 为所有阶段选择按钮添加事件监听
function bindStageSelectButtons(){
  const buttons = document.querySelectorAll(".stageSelectBtn");
  buttons.forEach(btn => {
    // 移除旧的事件监听器（如果有）
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    // 添加新的事件监听器
    newBtn.addEventListener("click", ()=>{
      const targetStageStr = newBtn.getAttribute("data-stage");
      const targetStage = targetStageStr.includes(".") ? parseFloat(targetStageStr) : parseInt(targetStageStr);
      jumpToStage(targetStage);
    });
  });
}

// 立即绑定（如果元素已存在）
if(document.readyState === "loading"){
  document.addEventListener("DOMContentLoaded", () => {
    bindStageSelectButtons();
    initStars(); // Initialize stars for Mystic Astral Clockwork animation
  });
} else {
  // DOM 已经加载完成，立即绑定
  bindStageSelectButtons();
  initStars(); // Initialize stars for Mystic Astral Clockwork animation
}

//   键盘事件：按 q 键显示/隐藏阶段选择按钮和ギャラリー按钮
document.addEventListener("keydown", (e) => {
  // 只响应 q 键（不区分大小写）
  if(e.key.toLowerCase() === 'q'){
    const stageSelectButtons = document.getElementById("stageSelectButtons");
    if(stageSelectButtons) {
      // 切换显示/隐藏
      stageSelectButtons.classList.toggle("visible");
    }
    // 在stage3时，按q键显示/隐藏ギャラリー按钮
    if(stage === 3) {
      const galleryBtn = document.getElementById("galleryBtn");
      if(galleryBtn) {
        if(galleryBtn.style.display === "none" || galleryBtn.style.display === "") {
          galleryBtn.style.display = "block";
        } else {
          galleryBtn.style.display = "none";
        }
      }
    }
  }
});

//   Mediapipe
let handsData = [];
const video = document.getElementById("videoElement");
async function initUserCamera(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:true});
    video.srcObject = stream;
    await video.play().catch(()=>{});
  }catch(err){}
}
initUserCamera();
let hands = null;
if(typeof Hands !== "undefined"){
  hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  hands.setOptions({ 
    maxNumHands:2, 
    modelComplexity:1, 
    // 降低一点置信度阈值，防止远距离手偶尔"消失"
    minDetectionConfidence:0.5, 
    minTrackingConfidence:0.5 
  });
  hands.onResults(res=>{
    handsData = res.multiHandLandmarks || [];
    
    // 修复：只有当画面中真正检测到手时，才视为"用户活跃"，重置倒计时
    if (handsData.length > 0) {
        updateActivityTime();
    }
    
    controlCameraByHands(handsData);
  });
}
let camMP = null;
function startMediaPipeCamera(){
  if(!hands) return;
  if(typeof Camera === "undefined") return;
  camMP = new Camera(video,{
    onFrame:async()=>{ await hands.send({image:video}); },
    width:640, height:480
  });
  camMP.start().catch(()=>{});
}

// 初始化 MediaPipe 手势识别（重启摄像头与手势识别）
function initHands(){
  // 停止旧的 MediaPipe 实例
  if(camMP) {
    try {
      camMP.stop();
    } catch(e) {}
    camMP = null;
  }
  // 重新启动 MediaPipe 摄像头
  setTimeout(() => {
    startMediaPipeCamera();
  }, 100);
}

startMediaPipeCamera();

//   Animate
function animate(){
  if(stage !== 0 && stage !== 1 && stage !== 1.5 && stage !== 2 && stage !== 3){
    const now = performance.now();
    if(now - lastActivityTime >= INACTIVITY_TIMEOUT) returnToTitle();
  }
  if(stage === 0) detectTitleHands();
  if(stage === 2) detectStage2HandsAndMaybeWarp();
  setToolOverlayVisible(stage === 2);
  const stage1Hint = document.getElementById('stage1Hint');
  if(stage1Hint) {
    if(stage === 1) {
      stage1Hint.style.display = 'block';
      requestAnimationFrame(() => {
        stage1Hint.classList.add("visible");
      });
    } else {
      stage1Hint.classList.remove("visible");
      // 等待渐变消失后再隐藏
      setTimeout(() => {
        if(stage !== 1) stage1Hint.style.display = 'none';
      }, 600);
    }
  }
  const stage2Hint = document.getElementById('stage2Hint');
  if(stage2Hint) {
    if(stage === 2 && !stage2Warping) {
      stage2Hint.style.display = 'block';
      requestAnimationFrame(() => {
        stage2Hint.classList.add("visible");
      });
    } else {
      stage2Hint.classList.remove("visible");
      // 等待渐变消失后再隐藏
      setTimeout(() => {
        if(stage !== 2 || stage2Warping) stage2Hint.style.display = 'none';
      }, 600);
    }
  }
  const stage2TopHint = document.getElementById('stage2TopHint');
  if(stage2TopHint) {
    if(stage === 2 && !stage2Warping) {
      stage2TopHint.style.display = 'block';
      requestAnimationFrame(() => {
        stage2TopHint.classList.add("visible");
      });
    } else {
      stage2TopHint.classList.remove("visible");
      // 等待渐变消失后再隐藏
      setTimeout(() => {
        if(stage !== 2 || stage2Warping) stage2TopHint.style.display = 'none';
      }, 600);
    }
  }

  warpAmplifier = 1.0;
  if(stage2Warping){
    const now = performance.now();
    const elapsedTime = now - stage2WarpStart;
    const t = clamp(elapsedTime / stage2WarpDuration, 0, 1);
    
    // 【恢复旧版】使用指数加速（exponential easing）
    // t = 1 - Math.exp(-0.003 * elapsedTime) 会产生从慢到快的"吸进去"感觉
    const exponentialT = 1 - Math.exp(-0.003 * elapsedTime);
    const ease = clamp(exponentialT, 0, 1);

    // 1. 【恢复旧版】相机移动使用指数加速
    camera.position.z = stage2WarpStartZ + (stage2WarpTargetZ - stage2WarpStartZ) * ease;
    
    // 2. FOV 拉伸
    const extraFOV = Math.sin(t * Math.PI) * 50; 
    camera.fov = 60 + extraFOV;
    camera.updateProjectionMatrix();

    // 3. 【恢复旧版】星系疯狂加速旋转 (视觉冲击力的来源)
    // 速度从 0.033 飙升到 0.8，产生"漩涡"感
    titleGalaxyRotationSpeed = 0.033 + ease * 0.8;

    // 4. 【恢复旧版】星座深度飞行（Z 轴范围更大）
    if(shadowConstellation){
      const baseZ = (shadowConstellation.userData && shadowConstellation.userData.baseZ !== undefined)
        ? shadowConstellation.userData.baseZ
        : -1800;
      
      // 旧版效果：从 baseZ + 3000 飞到 baseZ - 2500
      const startZ = baseZ + 3000;
      const endZ = baseZ - 2500;
      
      // 使用 easeOutExpo 缓动
      const easeOutExpo = t >= 1 ? 1 : 1 - Math.pow(2, -10 * t);
      
      shadowConstellation.scale.set(1, 1, 1);
      shadowConstellation.position.z = THREE.MathUtils.lerp(startZ, endZ, easeOutExpo);
      shadowConstellation.rotation.set(0, 0, 0);
    }

    // 5. 【恢复旧版】粒子加速（在 updateTitleBackground 中处理，这里设置标志）
    // 粒子加速逻辑会在 updateTitleBackground 中根据 stage2Warping 状态处理

    if(t >= 1){
      camera.fov = 60;
      camera.updateProjectionMatrix();
      titleGalaxyRotationSpeed = 0.033; // 复位速度
      finalizeStage2ToStage3();
    }
  }

  if(stage === 0) {
    // 标题界面：隐藏视频背景和画布
    const videoElement = document.getElementById("videoElement");
    if(videoElement) {
      videoElement.classList.remove("stage1Visible");
    }
    artCanvas.style.display = "none";
    uiCanvas.style.display = "none";
    
    // 播放标题BGM（如果还没播放）
    const titleBGM = document.getElementById("titleBGM");
    if (titleBGM && titleBGM.paused && !warpTextState.isActive) {
      titleBGM.volume = 1.0;
      titleBGM.play().catch(e => console.log("标题BGM播放失败:", e));
    }
    
    // 显示标题覆盖层（如果文字未激活）
    const titleOverlay = document.getElementById("titleOverlay");
    if(titleOverlay && !warpTextState.isActive) {
      titleOverlay.style.display = "flex";
    }
    
    // 显示提示文字（仅在标题界面显示）
    const instructionText = document.getElementById("instructionText");
    if(instructionText) {
      instructionText.style.display = "block";
      instructionText.style.opacity = "0.85";
    }
  } else if(stage===1) doStage1();
  else if(stage==="stage1To1_5") doStage1To1_5Transition();
  else if(stage==="stage1_5To2") doStage1_5To2Transition();
  else if(stage===1.5) doStage1_5();
  else if(stage===2) doStage2();
  else {
    // 非 stage1 和 stage1.5 时隐藏视频背景
    const videoElement = document.getElementById("videoElement");
    if(videoElement) {
      videoElement.classList.remove("stage1Visible");
    }
    // 非标题界面时隐藏提示文字
    const instructionText = document.getElementById("instructionText");
    if(instructionText) {
      instructionText.style.display = "none";
    }
  }

  // 1. 先计算相机最新位置
  updateCamera();
  
  // 2. 紧接着把背景瞬移到相机前方（确保绝不穿模）
  updateTitleBackground();
  
  warpStarfield();
  rotateDeepSpace();

  const STROKE_SHOW_DIST = 3000;
  for(let rec of creations){
    if(!rec.group) continue;
    const line = rec.group.userData.strokeLine;
    if(line){
      const d = camera.position.distanceTo(rec.group.position);
      line.visible = (d < STROKE_SHOW_DIST);
    }
  }

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

// 全局定时器已移除，改用 updateActivityTime() 中的倒计时方案

// 添加事件监听器：用户操作时更新活动时间
window.addEventListener('mousemove', updateActivityTime);
window.addEventListener('touchmove', updateActivityTime);
window.addEventListener('pointermove', updateActivityTime);

// 页面加载时初始化倒计时（仅在非标题界面时启动）
if (stage !== 0) {
  updateActivityTime();
}


</script>

</body>
</html>
